/*
 * Driver for the AP0202 camera sensor.
 *
 * Copyright (c) 2011-2015, The Linux Foundation. All rights reserved.
 * Copyright (C) 2015 By Tech Design S.L. All Rights Reserved.
 * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
 *
 * Based on:
 * - the AP0202 driver from QC msm-3.10 kernel on codeaurora.org:
 *   https://us.codeaurora.org/cgit/quic/la/kernel/msm-3.10/tree/drivers/
 *       media/platform/msm/camera_v2/sensor/ap0202.c?h=LA.BR.1.2.4_rb1.41
 * - the OV5640 driver posted on linux-media:
 *   https://www.mail-archive.com/linux-media%40vger.kernel.org/msg92671.html
 */

/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <linux/bitops.h>
#include <linux/clk.h>
#include <linux/delay.h>
#include <linux/device.h>
#include <linux/gpio/consumer.h>
#include <linux/i2c.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/mutex.h>
#include <linux/of.h>
#include <linux/of_graph.h>
#include <linux/regulator/consumer.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <media/v4l2-ctrls.h>
#include <media/v4l2-of.h>
#include <media/v4l2-subdev.h>

static DEFINE_MUTEX(ap0202_lock);

/* HACKs here! */

#include <../drivers/media/platform/msm/cci/msm_cci.h>

#ifdef dev_dbg
	#undef dev_dbg
	#define dev_dbg dev_err
#endif

#define AP0202_VOLTAGE_ANALOG               2800000
#define AP0202_VOLTAGE_DIGITAL_CORE         1500000
#define AP0202_VOLTAGE_DIGITAL_IO           1800000


#define AP0202_SYSTEM_CTRL0		0x0100
#define	AP0202_SYSTEM_CTRL0_START	0x01
#define AP0202_SYSTEM_CTRL0_STOP 0x00

#define AP0202_CHIP_ID		    0x0000
#define	AP0202_CHIP_ID_WORD 	0x0064

#define TOSHIBA_BRG_ID          0x0000
#define TOSHIBA_BRG_ID_WORD     0x4401



#define AP0202_AWB_MANUAL_CONTROL	0x3406
#define		AP0202_AWB_MANUAL_ENABLE	BIT(0)
#define AP0202_AEC_PK_MANUAL		0x3503
#define		AP0202_AEC_MANUAL_ENABLE	BIT(0)
#define		AP0202_AGC_MANUAL_ENABLE	BIT(1)
#define AP0202_TIMING_TC_REG20		0x3820
#define		AP0202_SENSOR_VFLIP		BIT(1)
#define		AP0202_ISP_VFLIP		BIT(2)
#define AP0202_TIMING_TC_REG21		0x3821
#define		AP0202_SENSOR_MIRROR		BIT(1)
#define AP0202_PRE_ISP_TEST_SETTING_1	0x503d
#define		AP0202_TEST_PATTERN_MASK	0x3
#define		AP0202_SET_TEST_PATTERN(x)	((x) & AP0202_TEST_PATTERN_MASK)
#define		AP0202_TEST_PATTERN_ENABLE	BIT(7)
#define AP0202_SDE_SAT_U		0x5583
#define AP0202_SDE_SAT_V		0x5584

enum ap0202_mode {
	AP0202_MODE_MIN = 0,
	AP0202_MODE_1080P = 0,
	AP0202_MODE_MAX = 1
};

struct reg_value {
	u8 reg;
	u16 val;
};

struct ap0202_mode_info {
	enum ap0202_mode mode;
	u32 width;
	u32 height;
	struct reg_value *data;
	u32 data_size;
};

struct ap0202 {
	struct i2c_client *i2c_client;
	struct device *dev;
	struct v4l2_subdev sd;
	struct media_pad pad;
	struct v4l2_of_endpoint ep;
	struct v4l2_mbus_framefmt fmt;
	struct v4l2_rect crop;
	struct clk *xclk;
	/* External clock frequency currently supported is 23880000Hz */
	u32 xclk_freq;

	struct regulator *io_regulator;
	struct regulator *core_regulator;
	struct regulator *analog_regulator;

	enum ap0202_mode current_mode;

	/* Cached control values */
	struct v4l2_ctrl_handler ctrls;
	struct v4l2_ctrl *saturation;
	struct v4l2_ctrl *hflip;
	struct v4l2_ctrl *vflip;
	struct v4l2_ctrl *autogain;
	struct v4l2_ctrl *autoexposure;
	struct v4l2_ctrl *awb;
	struct v4l2_ctrl *pattern;

	struct mutex power_lock; /* lock to protect power state */
	bool power;

	struct gpio_desc *enable_gpio;
	struct gpio_desc *rst_gpio;

	struct v4l2_subdev *cci;
};

struct tc358746_reg_struct {
	u8	size;
	u16	addr;
	u32	val;
};
static inline struct ap0202 *to_ap0202(struct v4l2_subdev *sd)
{
	return container_of(sd, struct ap0202, sd);
}
/*Some controllers(MIPI receiver detect the LPxx transaction),so stay in standby after the initial setting*/

static struct tc358746_reg_struct reg_parallel_in_mipi_out[] = {

	{2, 0x0004, 0x0004},
	{2, 0x0002, 0x0001},
	{2, 0x0002, 0x0000},
	{2, 0x0016, 0x50C6},
	{2, 0x0018, 0x0213},
	
	{2, 0x0006, 0x0030},
	{2, 0x0008, 0x0060},//YUV422 8-bit on 16bits bus(Mode1 or Mode2)
	{2, 0x0022, 0x0F00},
	
	{4, 0x0140, 0x00000000},
	{4, 0x0144, 0x00000000},
	{4, 0x0148, 0x00000000},
	{4, 0x014C, 0x00000001},
	{4, 0x0150, 0x00000001},
	
	{4, 0x0210, 0x00002C00},
	{4, 0x0214, 0x00000005},
	{4, 0x0218, 0x00001E05},
	{4, 0x021C, 0x00000002},
	{4, 0x0220, 0x00000204},
	{4, 0x0224, 0x00004988},
	{4, 0x0228, 0x00000009},
	{4, 0x022C, 0x00000003},
	{4, 0x0234, 0x00000007},
	{4, 0x0238, 0x00000001},
	{4, 0x0204, 0x00000001},//TX PPI starts
	
	{4, 0x0518, 0x00000001},
	{4, 0x0500, 0xA30080A3},
	
	{2, 0x0004, 0x0245},

};

const u16 ap0202_1080p[]={

0x0040, 0x8E00, 	// COMMAND_REGISTER
0x098E, 0x7C00, 	// LOGICAL_ADDRESS_ACCESS [CMD_HANDLER_PARAMS_POOL_0]
0xFC00, 0x0000, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0054, 	// CMD_HANDLER_PARAMS_POOL_1
0x0040, 0x8706, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0x0982, 0x0001, 	// ACCESS_CTL_STAT
0x098A, 0x4750, 	// PHYSICAL_ADDRESS_ACCESS
0xC750, 0xC0F1,
0xC752, 0x0CEA,
0xC754, 0x1340,
0xC756, 0x75CF,
0xC758, 0xFFFF,
0xC75A, 0xA1A8,
0xC75C, 0x8DC4,
0xC75E, 0x0E0B,
0xC760, 0x10D1,
0xC762, 0xD804,
0xC764, 0xAD04,
0xC766, 0x70CF,
0xC768, 0x0001,
0xC76A, 0x7C06,
0xC76C, 0x7840,
0xC76E, 0x0E0F,
0xC770, 0x1111,
0xC772, 0xD800,
0xC774, 0x0CEE,
0xC776, 0x0760,
0xC778, 0xAD04,
0xC77A, 0x0531,
0xC77C, 0x1340,
0xC77E, 0x78E0,
0xC780, 0xD900,
0xC782, 0xF00A,
0xC784, 0x70CF,
0xC786, 0xFFFF,
0xC788, 0xC79C,
0xC78A, 0x7835,
0xC78C, 0x8041,
0xC78E, 0x8000,
0xC790, 0xE102,
0xC792, 0xA040,
0xC794, 0x09F1,
0xC796, 0x8094,
0xC798, 0x7FE0,
0xC79A, 0xD800,
0xC79C, 0xFFFF,
0xC79E, 0xC160,
0xC7A0, 0xFFFF,
0xC7A2, 0xC750,
0x098E, 0x0000, 	// LOGICAL_ADDRESS_ACCESS
0xFC00, 0x0030, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0140, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0xA103, 	// CMD_HANDLER_PARAMS_POOL_2
0xFC06, 0x0204, 	// CMD_HANDLER_PARAMS_POOL_3
0xFC08, 0x0054, 	// CMD_HANDLER_PARAMS_POOL_4
0x0040, 0x8702, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0x0040, 0x8701, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0xFC00, 0x0054, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x01CC, 	// CMD_HANDLER_PARAMS_POOL_1
0x0040, 0x8706, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0x0982, 0x0001, 	// ACCESS_CTL_STAT
0x098A, 0x47A4, 	// PHYSICAL_ADDRESS_ACCESS
0xC7A4, 0xC0F1,
0xC7A6, 0x0C96,
0xC7A8, 0x1360,
0xC7AA, 0xD900,
0xC7AC, 0xC1A1,
0xC7AE, 0x75CF,
0xC7B0, 0xFFFF,
0xC7B2, 0x82A4,
0xC7B4, 0x8DC0,
0xC7B6, 0x0BEE,
0xC7B8, 0x03E0,
0xC7BA, 0x708B,
0xC7BC, 0x71CF,
0xC7BE, 0x0001,
0xC7C0, 0x7E2A,
0xC7C2, 0x081B,
0xC7C4, 0x0051,
0xC7C6, 0xC020,
0xC7C8, 0xE080,
0xC7CA, 0x20CC,
0xC7CC, 0x8062,
0xC7CE, 0xF407,
0xC7D0, 0xD802,
0xC7D2, 0x7960,
0xC7D4, 0xAD00,
0xC7D6, 0xADC0,
0xC7D8, 0xF002,
0xC7DA, 0x7940,
0xC7DC, 0x04CD,
0xC7DE, 0x1360,
0xC7E0, 0xC0A1,
0xC7E2, 0x78E0,
0xC7E4, 0xC0F1,
0xC7E6, 0x0C4E,
0xC7E8, 0x1340,
0xC7EA, 0x0CE6,
0xC7EC, 0x03C0,
0xC7EE, 0x701A,
0xC7F0, 0x0D0A,
0xC7F2, 0x1360,
0xC7F4, 0x218A,
0xC7F6, 0x0A0F,
0xC7F8, 0x7708,
0xC7FA, 0x75CF,
0xC7FC, 0xFFFF,
0xC7FE, 0xA168,
0xC800, 0x70CF,
0xC802, 0x0001,
0xC804, 0x8712,
0xC806, 0x7840,
0xC808, 0x1524,
0xC80A, 0x1080,
0xC80C, 0xE82D,
0xC80E, 0x76CF,
0xC810, 0xFFFF,
0xC812, 0xB530,
0xC814, 0x9623,
0xC816, 0x75CF,
0xC818, 0xFFFF,
0xC81A, 0xB5B0,
0xC81C, 0x9516,
0xC81E, 0xDB7D,
0xC820, 0xBB0A,
0xC822, 0x782C,
0xC824, 0x2942,
0xC826, 0x77C0,
0xC828, 0x712F,
0xC82A, 0x0EFE,
0xC82C, 0x1360,
0xC82E, 0xDA00,
0xC830, 0x730A,
0xC832, 0x0E1A,
0xC834, 0x1360,
0xC836, 0xDA00,
0xC838, 0x72CF,
0xC83A, 0x0000,
0xC83C, 0xFFFF,
0xC83E, 0x7150,
0xC840, 0x22CA,
0xC842, 0x0045,
0xC844, 0x71CF,
0xC846, 0xFFFF,
0xC848, 0xADB4,
0xC84A, 0x9122,
0xC84C, 0x1EC0,
0xC84E, 0x1084,
0xC850, 0x854A,
0xC852, 0x7230,
0xC854, 0x21CA,
0xC856, 0x008D,
0xC858, 0xB907,
0xC85A, 0x61F8,
0xC85C, 0xB861,
0xC85E, 0x0C9E,
0xC860, 0x1360,
0xC862, 0x71E9,
0xC864, 0xB51F,
0xC866, 0x0435,
0xC868, 0x1340,
0xC86A, 0x78E0,
0xC86C, 0x8850,
0xC86E, 0xD980,
0xC870, 0xEA08,
0xC872, 0x71CF,
0xC874, 0xFFFF,
0xC876, 0xAD10,
0xC878, 0x21F4,
0xC87A, 0x0081,
0xC87C, 0xB907,
0xC87E, 0xB925,
0xC880, 0x8851,
0xC882, 0xEA09,
0xC884, 0x72CF,
0xC886, 0xFFFF,
0xC888, 0xACF4,
0xC88A, 0x9254,
0xC88C, 0x7A2C,
0xC88E, 0x2941,
0xC890, 0x7141,
0xC892, 0x9043,
0xC894, 0x7A2C,
0xC896, 0x9011,
0xC898, 0x2941,
0xC89A, 0x7141,
0xC89C, 0x782C,
0xC89E, 0x7FE0,
0xC8A0, 0x2941,
0xC8A2, 0x71C0,
0xC8A4, 0xC0F1,
0xC8A6, 0x0B92,
0xC8A8, 0x1340,
0xC8AA, 0x7508,
0xC8AC, 0xFFF0,
0xC8AE, 0xB807,
0xC8B0, 0x71CF,
0xC8B2, 0xFFFF,
0xC8B4, 0xB5B0,
0xC8B6, 0x0C46,
0xC8B8, 0x1360,
0xC8BA, 0x913D,
0xC8BC, 0x7708,
0xC8BE, 0x9500,
0xC8C0, 0x9521,
0xC8C2, 0x0A16,
0xC8C4, 0x13E0,
0xC8C6, 0x9547,
0xC8C8, 0x7608,
0xC8CA, 0x70E9,
0xC8CC, 0x0A56,
0xC8CE, 0x10E0,
0xC8D0, 0xD908,
0xC8D2, 0x7508,
0xC8D4, 0x2582,
0xC8D6, 0x101C,
0xC8D8, 0x70C9,
0xC8DA, 0x0A4A,
0xC8DC, 0x10E0,
0xC8DE, 0xD908,
0xC8E0, 0x03C1,
0xC8E2, 0x1360,
0xC8E4, 0x60B8,
0xC8E6, 0x78E0,
0xC8E8, 0xC0F1,
0xC8EA, 0x0B4E,
0xC8EC, 0x1340,
0xC8EE, 0x77CF,
0xC8F0, 0xFFFF,
0xC8F2, 0x8004,
0xC8F4, 0x0BC2,
0xC8F6, 0x03C0,
0xC8F8, 0x75CF,
0xC8FA, 0xFFFF,
0xC8FC, 0xAC00,
0xC8FE, 0x7608,
0xC900, 0x8F05,
0xC902, 0x9522,
0xC904, 0x7610,
0xC906, 0x21D1,
0xC908, 0x80A2,
0xC90A, 0xF213,
0xC90C, 0xE680,
0xC90E, 0x26CC,
0xC910, 0x9062,
0xC912, 0xF40F,
0xC914, 0x70CF,
0xC916, 0xFFFF,
0xC918, 0xB960,
0xC91A, 0xFFE3,
0xC91C, 0xB504,
0xC91E, 0x08DE,
0xC920, 0x0220,
0xC922, 0xD800,
0xC924, 0xD801,
0xC926, 0xAD0E,
0xC928, 0xAFC5,
0xC92A, 0xD800,
0xC92C, 0xF005,
0xC92E, 0x70CF,
0xC930, 0x0000,
0xC932, 0x0F7E,
0xC934, 0x7840,
0xC936, 0x036D,
0xC938, 0x1340,
0xC93A, 0x78E0,
0xC93C, 0xD900,
0xC93E, 0xF00A,
0xC940, 0x70CF,
0xC942, 0xFFFF,
0xC944, 0xC958,
0xC946, 0x7835,
0xC948, 0x8041,
0xC94A, 0x8000,
0xC94C, 0xE102,
0xC94E, 0xA040,
0xC950, 0x09F1,
0xC952, 0x8194,
0xC954, 0x7FE0,
0xC956, 0xD800,
0xC958, 0xFFFF,
0xC95A, 0xC164,
0xC95C, 0xFFFF,
0xC95E, 0xC7A4,
0xC960, 0xFFFF,
0xC962, 0xC198,
0xC964, 0xFFFF,
0xC966, 0xC7E4,
0xC968, 0xFFFF,
0xC96A, 0xBB6C,
0xC96C, 0xFFFF,
0xC96E, 0xC8E8,
0x098E, 0x0000, 	// LOGICAL_ADDRESS_ACCESS
0xFC00, 0x01EC, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0240, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0xA103, 	// CMD_HANDLER_PARAMS_POOL_2
0xFC06, 0x0204, 	// CMD_HANDLER_PARAMS_POOL_3
0xFC08, 0x01CC, 	// CMD_HANDLER_PARAMS_POOL_4
0x0040, 0x8702, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0x0040, 0x8701, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0xFC00, 0x0220, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x005C, 	// CMD_HANDLER_PARAMS_POOL_1
0x0040, 0x8706, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0x0982, 0x0001, 	// ACCESS_CTL_STAT
0x098A, 0x4970, 	// PHYSICAL_ADDRESS_ACCESS
0xC970, 0xC0F1,
0xC972, 0x0ACA,
0xC974, 0x1340,
0xC976, 0x71CF,
0xC978, 0x0001,
0xC97A, 0x2896,
0xC97C, 0x7940,
0xC97E, 0x250A,
0xC980, 0x9000,
0xC982, 0x76CF,
0xC984, 0xFFFF,
0xC986, 0xB51C,
0xC988, 0xF407,
0xC98A, 0x0D4A,
0xC98C, 0x0B20,
0xC98E, 0x8E12,
0xC990, 0x0C6A,
0xC992, 0x0AE0,
0xC994, 0xD801,
0xC996, 0x0315,
0xC998, 0x1360,
0xC99A, 0x70A9,
0xC99C, 0xD900,
0xC99E, 0xF00A,
0xC9A0, 0x70CF,
0xC9A2, 0xFFFF,
0xC9A4, 0xC9C4,
0xC9A6, 0x7835,
0xC9A8, 0x8041,
0xC9AA, 0x8000,
0xC9AC, 0xE102,
0xC9AE, 0xA040,
0xC9B0, 0x09F1,
0xC9B2, 0x8094,
0xC9B4, 0x71CF,
0xC9B6, 0xFFFF,
0xC9B8, 0xB51C,
0xC9BA, 0xD808,
0xC9BC, 0xA912,
0xC9BE, 0x7FE0,
0xC9C0, 0xD800,
0xC9C2, 0x0000,
0xC9C4, 0xFFFF,
0xC9C6, 0xBFE4,
0xC9C8, 0xFFFF,
0xC9CA, 0xC970,
0x098E, 0x0000, 	// LOGICAL_ADDRESS_ACCESS
0xFC00, 0x024C, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0340, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0xA103, 	// CMD_HANDLER_PARAMS_POOL_2
0xFC06, 0x0204, 	// CMD_HANDLER_PARAMS_POOL_3
0xFC08, 0x005C, 	// CMD_HANDLER_PARAMS_POOL_4
0x0040, 0x8702, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0x0040, 0x8701, 	// COMMAND_REGISTER
//OLL  COMMAND_R,EGISTER::DOORBELL =>  0x00
0xCC02, 0x0493, 	// SENSOR_MGR_MODE
0x0040, 0x8D00, 	// COMMAND_REGISTER
0x0040, 0x8D01, 	// COMMAND_REGISTER
0xFC00, 0x3088, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0280, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x0000, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C45,
0xFC04, 0x5872,
0xFC06, 0x9B4A,
0xFC08, 0x3143,
0xFC0A, 0x428E,
0xFC0C, 0x032A,
0xFC0E, 0x1400,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C45,
0xFC04, 0x787B,
0xFC06, 0x3DFF,
0xFC08, 0x3DFF,
0xFC0A, 0x3DEA,
0xFC0C, 0x2A04,
0xFC0E, 0x3D00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C10,
0xFC04, 0x2A05,
0xFC06, 0x2A15,
0xFC08, 0x352A,
0xFC0A, 0x053D,
0xFC0C, 0x1045,
0xFC0E, 0x5800,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C2A,
0xFC04, 0x042A,
0xFC06, 0x143D,
0xFC08, 0xFF3D,
0xFC0A, 0xFF3D,
0xFC0C, 0xEA2A,
0xFC0E, 0x0400,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C62,
0xFC04, 0x2A28,
0xFC06, 0x8E00,
0xFC08, 0x362A,
0xFC0A, 0x083D,
0xFC0C, 0x647A,
0xFC0E, 0x3D00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C04,
0xFC04, 0x442C,
0xFC06, 0x4B8F,
0xFC08, 0x0043,
0xFC0A, 0x0C2D,
0xFC0C, 0x6343,
0xFC0E, 0x1600,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C8E,
0xFC04, 0x032A,
0xFC06, 0xFC5C,
0xFC08, 0x1D57,
0xFC0A, 0x5449,
0xFC0C, 0x5F53,
0xFC0E, 0x0500,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C53,
0xFC04, 0x074D,
0xFC06, 0x2BF8,
0xFC08, 0x1016,
0xFC0A, 0x4C08,
0xFC0C, 0x5556,
0xFC0E, 0x2B00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0CB8,
0xFC04, 0x2B98,
0xFC06, 0x4E11,
0xFC08, 0x2904,
0xFC0A, 0x2984,
0xFC0C, 0x2994,
0xFC0E, 0x6000,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C5C,
0xFC04, 0x195C,
0xFC06, 0x1B45,
0xFC08, 0x4845,
0xFC0A, 0x0845,
0xFC0C, 0x8829,
0xFC0E, 0xB600,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C8E,
0xFC04, 0x012A,
0xFC06, 0xF83E,
0xFC08, 0x022A,
0xFC0A, 0xFA3F,
0xFC0C, 0x095C,
0xFC0E, 0x1B00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C29,
0xFC04, 0xB23F,
0xFC06, 0x0C3E,
0xFC08, 0x023E,
0xFC0A, 0x135C,
0xFC0C, 0x133F,
0xFC0E, 0x1100,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C3E,
0xFC04, 0x0B5F,
0xFC06, 0x2B90,
0xFC08, 0x2AF2,
0xFC0A, 0x2B80,
0xFC0C, 0x3E04,
0xFC0E, 0x3F00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C06,
0xFC04, 0x6029,
0xFC06, 0xA229,
0xFC08, 0xA35F,
0xFC0A, 0x4D19,
0xFC0C, 0x2AFA,
0xFC0E, 0x2900,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C83,
0xFC04, 0x45A8,
0xFC06, 0x3E07,
0xFC08, 0x2AFB,
0xFC0A, 0x3E29,
0xFC0C, 0x4588,
0xFC0E, 0x2100,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C3E,
0xFC04, 0x082A,
0xFC06, 0xFA5D,
0xFC08, 0x2992,
0xFC0A, 0x8810,
0xFC0C, 0x2B04,
0xFC0E, 0x8B00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C16,
0xFC04, 0x858D,
0xFC06, 0x484D,
0xFC08, 0x4E2B,
0xFC0A, 0x804C,
0xFC0C, 0x0B60,
0xFC0E, 0x3F00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C28,
0xFC04, 0x2AF2,
0xFC06, 0x3F0F,
0xFC08, 0x2982,
0xFC0A, 0x2983,
0xFC0C, 0x2943,
0xFC0E, 0x5C00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C15,
0xFC04, 0x5F4D,
0xFC06, 0x192A,
0xFC08, 0xFA45,
0xFC0A, 0x588E,
0xFC0C, 0x002A,
0xFC0E, 0x9800,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C3F,
0xFC04, 0x0612,
0xFC06, 0x444A,
0xFC08, 0x0443,
0xFC0A, 0x1605,
0xFC0C, 0x4316,
0xFC0E, 0x5800,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C43,
0xFC04, 0x165A,
0xFC06, 0x4316,
0xFC08, 0x0643,
0xFC0A, 0x1607,
0xFC0C, 0x4316,
0xFC0E, 0x8E00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C03,
0xFC04, 0x2A9C,
0xFC06, 0x4578,
0xFC08, 0x7B3F,
0xFC0A, 0x072A,
0xFC0C, 0x9D3E,
0xFC0E, 0x2E00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C45,
0xFC04, 0x5825,
0xFC06, 0x3E06,
0xFC08, 0x8E01,
0xFC0A, 0x2A98,
0xFC0C, 0x8E00,
0xFC0E, 0x1200,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C44,
0xFC04, 0x4B03,
0xFC06, 0x432D,
0xFC08, 0x4643,
0xFC0A, 0x16A3,
0xFC0C, 0x4316,
0xFC0E, 0x5D00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C0D,
0xFC04, 0x2944,
0xFC06, 0x8810,
0xFC08, 0x2B04,
0xFC0A, 0x530D,
0xFC0C, 0x8B16,
0xFC0E, 0x8500,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C44,
0xFC04, 0x8E03,
0xFC06, 0x2AFC,
0xFC08, 0x5C1D,
0xFC0A, 0x8D60,
0xFC0C, 0x5754,
0xFC0E, 0x4900,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C5F,
0xFC04, 0x5305,
0xFC06, 0x5307,
0xFC08, 0x4D2B,
0xFC0A, 0xF810,
0xFC0C, 0x164C,
0xFC0E, 0x0800,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C55,
0xFC04, 0x562B,
0xFC06, 0xB82B,
0xFC08, 0x984E,
0xFC0A, 0x1129,
0xFC0C, 0x0429,
0xFC0E, 0x8400,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C29,
0xFC04, 0x9460,
0xFC06, 0x5C19,
0xFC08, 0x5C1B,
0xFC0A, 0x4548,
0xFC0C, 0x4508,
0xFC0E, 0x4500,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C88,
0xFC04, 0x29B6,
0xFC06, 0x8E01,
0xFC08, 0x2AF8,
0xFC0A, 0x3E02,
0xFC0C, 0x2AFA,
0xFC0E, 0x3F00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C09,
0xFC04, 0x5C1B,
0xFC06, 0x29B2,
0xFC08, 0x3F0C,
0xFC0A, 0x3E02,
0xFC0C, 0x3E13,
0xFC0E, 0x5C00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C13,
0xFC04, 0x3F11,
0xFC06, 0x3E0B,
0xFC08, 0x5F2B,
0xFC0A, 0x902A,
0xFC0C, 0xF22B,
0xFC0E, 0x8000,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C3E,
0xFC04, 0x043F,
0xFC06, 0x0660,
0xFC08, 0x29A2,
0xFC0A, 0x29A3,
0xFC0C, 0x5F4D,
0xFC0E, 0x1C00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C2A,
0xFC04, 0xFA29,
0xFC06, 0x8345,
0xFC08, 0xA83E,
0xFC0A, 0x072A,
0xFC0C, 0xFB3E,
0xFC0E, 0x2900,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C45,
0xFC04, 0x8824,
0xFC06, 0x3E08,
0xFC08, 0x2AFA,
0xFC0A, 0x5D29,
0xFC0C, 0x9288,
0xFC0E, 0x1000,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C2B,
0xFC04, 0x048B,
0xFC06, 0x1686,
0xFC08, 0x8D48,
0xFC0A, 0x4D4E,
0xFC0C, 0x2B80,
0xFC0E, 0x4C00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C0B,
0xFC04, 0x603F,
0xFC06, 0x282A,
0xFC08, 0xF23F,
0xFC0A, 0x0F29,
0xFC0C, 0x8229,
0xFC0E, 0x8300,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C29,
0xFC04, 0x435C,
0xFC06, 0x155F,
0xFC08, 0x4D1C,
0xFC0A, 0x2AFA,
0xFC0C, 0x4558,
0xFC0E, 0x8E00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C00,
0xFC04, 0x2A98,
0xFC06, 0x3F06,
0xFC08, 0x4A73,
0xFC0A, 0x9D0A,
0xFC0C, 0x4316,
0xFC0E, 0x0B00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C43,
0xFC04, 0x168E,
0xFC06, 0x032A,
0xFC08, 0x9C45,
0xFC0A, 0x783F,
0xFC0C, 0x072A,
0xFC0E, 0x9D00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C3E,
0xFC04, 0x1245,
0xFC06, 0x583F,
0xFC08, 0x048E,
0xFC0A, 0x012A,
0xFC0C, 0x988E,
0xFC0E, 0x0000,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C91,
0xFC04, 0x769C,
0xFC06, 0x779C,
0xFC08, 0x4644,
0xFC0A, 0x1616,
0xFC0C, 0x907A,
0xFC0E, 0x1200,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C44,
0xFC04, 0x4B4A,
0xFC06, 0x0043,
0xFC08, 0x1663,
0xFC0A, 0x4316,
0xFC0C, 0x0843,
0xFC0E, 0x1600,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C50,
0xFC04, 0x4316,
0xFC06, 0x6543,
0xFC08, 0x1666,
0xFC0A, 0x4316,
0xFC0C, 0x8E03,
0xFC0E, 0x2A00,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C9C,
0xFC04, 0x4578,
0xFC06, 0x3F07,
0xFC08, 0x2A9D,
0xFC0A, 0x5D0C,
0xFC0C, 0x2944,
0xFC0E, 0x8800,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C10,
0xFC04, 0x2B04,
0xFC06, 0x530D,
0xFC08, 0x8B16,
0xFC0A, 0x863E,
0xFC0C, 0x1F45,
0xFC0E, 0x5800,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0C28,
0xFC04, 0x3E06,
0xFC06, 0x8E01,
0xFC08, 0x2A98,
0xFC0A, 0x8E00,
0xFC0C, 0x8D60,
0xFC0E, 0x1200,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3086,
0xFC02, 0x0444,
0xFC04, 0x4B2C,
0xFC06, 0x2C00,
0xFC08, 0x2A98,
0xFC0A, 0x8E00,
0xFC0C, 0x8D60,
0xFC0E, 0x1200,
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0x0040, 0x8D02, 	// COMMAND_REGISTER
0x0040, 0x8E01, 	// COMMAND_REGISTER
0xCCCC, 0x69 ,	// RESERVED_SENSOR_MGR_CC
0x0040, 0x8D00, 	// COMMAND_REGISTER
0x0040, 0x8D01, 	// COMMAND_REGISTER
0xFC00, 0x3ED6, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0234, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0xB300, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x2436, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0200, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x0E00, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x320C, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0201, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x8000, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x320E, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0203, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x0000, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3210, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0205, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x0000, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3204, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x020B, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x6D00, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x30FE, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0200, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x8000, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3ED8, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x027B, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x9900, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3EDC, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x029B, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0xA800, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3EDA, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x029B, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x9B00, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3092, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0200, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x6F00, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3EEC, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x021C, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x0400, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x30BA, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0277, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x9C00, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3EF6, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x02A7, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x0F00, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3044, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0204, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x1000, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3ED0, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x02FF, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x4400, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3ED4, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0203, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x1F00, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x30FE, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0200, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x8000, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3EE2, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0288, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x6600, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3EE4, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0266, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x2300, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x3EE6, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0222, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x6300, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x30E0, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0242, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x8300, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0xFC00, 0x30F0, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0212, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x8300, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0x0040, 0x8D02, 	// COMMAND_REGISTER
0xCAC8, 0x41 ,	// CAM_SYSCTL_PLL_CONTROL
0xCACA, 0x022F, 	// CAM_SYSCTL_PLL_DIVIDER_M_N_1_CLK
0xCACE, 0x010E, 	// CAM_SYSCTL_PLL_DIVIDER_M_N_NET
0xCAD0, 0x0033, 	// CAM_SYSCTL_PLL_DIVIDER_P_1_CLK
0xCAD4, 0x001F, 	// CAM_SYSCTL_PLL_DIVIDER_P_NET
0xCAD4, 0x001F, 	// CAM_SYSCTL_PLL_DIVIDER_P_NET
0xCAD8, 0x0000,
0xCADA, 0x0000, 	// CAM_SYSCTL_PLL_FRACTION_1_CLK
0xC806, 0x000C, 	// CAM_SENSOR_CFG_X_ADDR_START
0xC80A, 0x078B, 	// CAM_SENSOR_CFG_X_ADDR_END
0xC804, 0x0000, 	// CAM_SENSOR_CFG_Y_ADDR_START
0xC808, 0x0437, 	// CAM_SENSOR_CFG_Y_ADDR_END
0xC838, 0x0302,
0xC83A, 0x211B, 	// CAM_SENSOR_CONTROL_EXTERNAL_PLL
0xC840, 0x010C, 	// CAM_SENSOR_CONTROL_EXTERNAL_OUTPUT_CLK_DIV
0xC844, 0x0802, 	// CAM_SENSOR_CONTROL_OPERATION_MODE
0xC844, 0x0801, 	// CAM_SENSOR_CONTROL_OPERATION_MODE
0xC80C, 0x04BA,
0xC80E, 0x3674, 	// CAM_SENSOR_CFG_PIXCLK
0xC814, 0x049E, 	// CAM_SENSOR_CFG_FRAME_LENGTH_LINES
0xC816, 0x08BC, 	// CAM_SENSOR_CFG_LINE_LENGTH_PCK
0xC846, 0x0000, 	// CAM_SENSOR_CONTROL_READ_MODE****************************
0xC890, 0x00 ,	// CAM_MODE_SELECT
0xC8A0, 0x0000, 	// CAM_CROP_WINDOW_XOFFSET
0xC8A2, 0x0000, 	// CAM_CROP_WINDOW_YOFFSET
0xC8A4, 0x0780, 	// CAM_CROP_WINDOW_WIDTH
0xC8A6, 0x0438, 	// CAM_CROP_WINDOW_HEIGHT
0xC9F8, 0x0000, 	// CAM_STAT_AE_ALTM_FD_WINDOW_X_OFFSET
0xC9FA, 0x0000, 	// CAM_STAT_AE_ALTM_FD_WINDOW_Y_OFFSET
0xC9FC, 0x0780, 	// CAM_STAT_AE_ALTM_FD_WINDOW_WIDTH
0xC9FE, 0x0438, 	// CAM_STAT_AE_ALTM_FD_WINDOW_HEIGHT
0xCA00, 0x0000, 	// CAM_STAT_AWB_CLIP_WINDOW_X_OFFSET
0xCA02, 0x0000, 	// CAM_STAT_AWB_CLIP_WINDOW_Y_OFFSET
0xCA04, 0x0780, 	// CAM_STAT_AWB_CLIP_WINDOW_WIDTH
0xCA06, 0x0438, 	// CAM_STAT_AWB_CLIP_WINDOW_HEIGHT
0xCAE4, 0x0780, 	// CAM_OUTPUT_WIDTH
0xCAE6, 0x0438, 	// CAM_OUTPUT_HEIGHT
0xCAE8, 0x0011, 	// CAM_OUTPUT_FORMAT_YUV
0xCAE8, 0x0011, 	// CAM_OUTPUT_FORMAT_YUV
0xCAEA, 0x00 ,	// CAM_OUTPUT_FORMAT
0xCAEB, 0x00 ,	// CAM_OUTPUT_FORMAT_BAYER_PATH
0xCAF4, 0x249F, 	// CAM_OUTPUT_COMPRESSED_BIT_RATE_8K
0xCAF8, 0x0E ,	// CAM_OUTPUT_H264_CONTROL
0xCAFC, 0x4201, 	// CAM_PORT_PARALLEL_CONTROL
0xCAFC, 0x4201, 	// CAM_PORT_PARALLEL_CONTROL
0xCAFC, 0x4201, 	// CAM_PORT_PARALLEL_CONTROL
0xCAFC, 0x4201, 	// CAM_PORT_PARALLEL_CONTROL
0xCAFC, 0x4001, 	// CAM_PORT_PARALLEL_CONTROL
0xCAFC, 0x4001, 	// CAM_PORT_PARALLEL_CONTROL
0xCAFC, 0x4001, 	// CAM_PORT_PARALLEL_CONTROL
0xCAFC, 0xC001, 	// CAM_PORT_PARALLEL_CONTROL
0xCAFE, 0x08BC, 	// CAM_PORT_CONST_LINE_LENGTH
0xCB00, 0x0800, 	// CAM_PORT_MAX_PACKET_PAYLOAD
0x8C16, 0x19 ,	// NET_CFG_NET_CLOCK_FREQ
0xCAC4, 0x0000, 	// CAM_PGA_PGA_CONTROL
0x3600, 0x00F0, 	// P_G1_P0Q0
0x3602, 0xD789, 	// P_G1_P0Q1
0x3604, 0x4D70, 	// P_G1_P0Q2
0x3606, 0x6A8D, 	// P_G1_P0Q3
0x3608, 0x7CEE, 	// P_G1_P0Q4
0x360A, 0x00D0, 	// P_R_P0Q0
0x360C, 0x8F0B, 	// P_R_P0Q1
0x360E, 0x58B0, 	// P_R_P0Q2
0x3610, 0x2E2D, 	// P_R_P0Q3
0x3612, 0x0BCF, 	// P_R_P0Q4
0x3614, 0x00B0, 	// P_B_P0Q0
0x3616, 0xC149, 	// P_B_P0Q1
0x3618, 0x4950, 	// P_B_P0Q2
0x361A, 0x024E, 	// P_B_P0Q3
0x361C, 0x0B4E, 	// P_B_P0Q4
0x361E, 0x00D0, 	// P_G2_P0Q0
0x3620, 0xD2E9, 	// P_G2_P0Q1
0x3622, 0x4D10, 	// P_G2_P0Q2
0x3624, 0x67ED, 	// P_G2_P0Q3
0x3626, 0x1ACF, 	// P_G2_P0Q4
0x3628, 0x406B, 	// P_G1_P1Q0
0x362A, 0x1FC9, 	// P_G1_P1Q1
0x362C, 0x6750, 	// P_G1_P1Q2
0x362E, 0x4E0F, 	// P_G1_P1Q3
0x3630, 0xBCF3, 	// P_G1_P1Q4
0x3632, 0x138C, 	// P_R_P1Q0
0x3634, 0x366A, 	// P_R_P1Q1
0x3636, 0x6390, 	// P_R_P1Q2
0x3638, 0x2E2F, 	// P_R_P1Q3
0x363A, 0xB9D3, 	// P_R_P1Q4
0x363C, 0x2B4A, 	// P_B_P1Q0
0x363E, 0x008B, 	// P_B_P1Q1
0x3640, 0x6B30, 	// P_B_P1Q2
0x3642, 0x710F, 	// P_B_P1Q3
0x3644, 0xC413, 	// P_B_P1Q4
0x3646, 0x2A4B, 	// P_G2_P1Q0
0x3648, 0x080A, 	// P_G2_P1Q1
0x364A, 0x6BD0, 	// P_G2_P1Q2
0x364C, 0x0050, 	// P_G2_P1Q3
0x364E, 0xC4D3, 	// P_G2_P1Q4
0x3650, 0x6F90, 	// P_G1_P2Q0
0x3652, 0x5A2F, 	// P_G1_P2Q1
0x3654, 0xE631, 	// P_G1_P2Q2
0x3656, 0x8812, 	// P_G1_P2Q3
0x3658, 0x2155, 	// P_G1_P2Q4
0x365A, 0x6A30, 	// P_R_P2Q0
0x365C, 0x7FCF, 	// P_R_P2Q1
0x365E, 0xE291, 	// P_R_P2Q2
0x3660, 0x9C92, 	// P_R_P2Q3
0x3662, 0x2C75, 	// P_R_P2Q4
0x3664, 0x5F90, 	// P_B_P2Q0
0x3666, 0x618F, 	// P_B_P2Q1
0x3668, 0xED91, 	// P_B_P2Q2
0x366A, 0x9FB2, 	// P_B_P2Q3
0x366C, 0x1915, 	// P_B_P2Q4
0x366E, 0x6E90, 	// P_G2_P2Q0
0x3670, 0x5C0F, 	// P_G2_P2Q1
0x3672, 0xE111, 	// P_G2_P2Q2
0x3674, 0x9352, 	// P_G2_P2Q3
0x3676, 0x2135, 	// P_G2_P2Q4
0x3678, 0x7230, 	// P_G1_P3Q0
0x367A, 0x2D92, 	// P_G1_P3Q1
0x367C, 0xEEB5, 	// P_G1_P3Q2
0x367E, 0x8495, 	// P_G1_P3Q3
0x3680, 0x3C38, 	// P_G1_P3Q4
0x3682, 0x7B50, 	// P_R_P3Q0
0x3684, 0x2332, 	// P_R_P3Q1
0x3686, 0xED55, 	// P_R_P3Q2
0x3688, 0x8355, 	// P_R_P3Q3
0x368A, 0x3978, 	// P_R_P3Q4
0x368C, 0x74F0, 	// P_B_P3Q0
0x368E, 0x4032, 	// P_B_P3Q1
0x3690, 0xF9B5, 	// P_B_P3Q2
0x3692, 0x8D75, 	// P_B_P3Q3
0x3694, 0x4338, 	// P_B_P3Q4
0x3696, 0x7550, 	// P_G2_P3Q0
0x3698, 0x2CB2, 	// P_G2_P3Q1
0x369A, 0xF135, 	// P_G2_P3Q2
0x369C, 0x80F5, 	// P_G2_P3Q3
0x369E, 0x3B98, 	// P_G2_P3Q4
0x36A0, 0x90F2, 	// P_G1_P4Q0
0x36A2, 0xD4D2, 	// P_G1_P4Q1
0x36A4, 0x35B7, 	// P_G1_P4Q2
0x36A6, 0x1A75, 	// P_G1_P4Q3
0x36A8, 0x9B5A, 	// P_G1_P4Q4
0x36AA, 0xFF71, 	// P_R_P4Q0
0x36AC, 0xC832, 	// P_R_P4Q1
0x36AE, 0x3277, 	// P_R_P4Q2
0x36B0, 0x16F5, 	// P_R_P4Q3
0x36B2, 0x97BA, 	// P_R_P4Q4
0x36B4, 0x95B2, 	// P_B_P4Q0
0x36B6, 0x9373, 	// P_B_P4Q1
0x36B8, 0x3C77, 	// P_B_P4Q2
0x36BA, 0x6115, 	// P_B_P4Q3
0x36BC, 0xA0BA, 	// P_B_P4Q4
0x36BE, 0x95B2, 	// P_G2_P4Q0
0x36C0, 0xC492, 	// P_G2_P4Q1
0x36C2, 0x3517, 	// P_G2_P4Q2
0x36C4, 0x15B5, 	// P_G2_P4Q3
0x36C6, 0x9A9A, 	// P_G2_P4Q4
0x36C8, 0x018A, 	// CENTER_ROW
0x36CA, 0x03BE, 	// CENTER_COLUMN
0xCAC4, 0x0001, 	// CAM_PGA_PGA_CONTROL
0xC91E, 0x0A8C, 	// CAM_AWB_CCM_L_CTEMP
0xC920, 0x0FA0, 	// CAM_AWB_CCM_M_CTEMP
0xC922, 0x1964, 	// CAM_AWB_CCM_R_CTEMP
0xC924, 0x09C4, 	// CAM_AWB_COLOR_TEMPERATURE_MIN
0xC926, 0x1964, 	// CAM_AWB_COLOR_TEMPERATURE_MAX
0xC912, 0x005F, 	// CAM_AWB_CCM_L_RG_GAIN
0xC914, 0x016D, 	// CAM_AWB_CCM_L_BG_GAIN
0xC916, 0x00AF, 	// CAM_AWB_CCM_M_RG_GAIN
0xC918, 0x0148, 	// CAM_AWB_CCM_M_BG_GAIN
0xC91A, 0x0096, 	// CAM_AWB_CCM_R_RG_GAIN
0xC91C, 0x00B4, 	// CAM_AWB_CCM_R_BG_GAIN
0xC982, 0x82 ,	// CAM_AWB_K_R_L
0xC983, 0x80 ,	// CAM_AWB_K_G_L
0xC984, 0x86 ,	// CAM_AWB_K_B_L
0xC985, 0x84 ,	// CAM_AWB_K_R_R
0xC986, 0x82 ,	// CAM_AWB_K_G_R
0xC987, 0x80 ,	// CAM_AWB_K_B_R
0xC980, 0x1450, 	// CAM_AWB_TINTS_CTEMP_THRESHOLD
0xC8DC, 0x013E, 	// CAM_AWB_CCM_L_0
0xC8DE, 0xFFDB, 	// CAM_AWB_CCM_L_1
0xC8E0, 0xFFE7, 	// CAM_AWB_CCM_L_2
0xC8E2, 0xFF75, 	// CAM_AWB_CCM_L_3
0xC8E4, 0x01B8, 	// CAM_AWB_CCM_L_4
0xC8E6, 0xFFD2, 	// CAM_AWB_CCM_L_5
0xC8E8, 0xFF52, 	// CAM_AWB_CCM_L_6
0xC8EA, 0xFF1A, 	// CAM_AWB_CCM_L_7
0xC8EC, 0x0295, 	// CAM_AWB_CCM_L_8
0xC8EE, 0x01B0, 	// CAM_AWB_CCM_M_0
0xC8F0, 0xFF40, 	// CAM_AWB_CCM_M_1
0xC8F2, 0x0010, 	// CAM_AWB_CCM_M_2
0xC8F4, 0xFF87, 	// CAM_AWB_CCM_M_3
0xC8F6, 0x01A2, 	// CAM_AWB_CCM_M_4
0xC8F8, 0xFFD7, 	// CAM_AWB_CCM_M_5
0xC8FA, 0xFFD3, 	// CAM_AWB_CCM_M_6
0xC8FC, 0xFF63, 	// CAM_AWB_CCM_M_7
0xC8FE, 0x01CB, 	// CAM_AWB_CCM_M_8
0xC900, 0x0154, 	// CAM_AWB_CCM_R_0
0xC902, 0xFFCD, 	// CAM_AWB_CCM_R_1
0xC904, 0xFFDE, 	// CAM_AWB_CCM_R_2
0xC906, 0xFFB1, 	// CAM_AWB_CCM_R_3
0xC908, 0x013B, 	// CAM_AWB_CCM_R_4
0xC90A, 0xFFEC, 	// CAM_AWB_CCM_R_5
0xC90C, 0xFFD9, 	// CAM_AWB_CCM_R_6
0xC90E, 0xFF9C, 	// CAM_AWB_CCM_R_7
0xC910, 0x018B, 	// CAM_AWB_CCM_R_8
0xC97D, 0x10 ,	// CAM_AWB_MODE
0xC92A, 0x0020, 	// CAM_AWB_X_SHIFT
0xC92C, 0x0018, 	// CAM_AWB_Y_SHIFT
0xC92E, 0x0080, 	// CAM_AWB_RECIP_X_SCALE
0xC930, 0x0080, 	// CAM_AWB_RECIP_Y_SCALE
0xC932, 0x0005, 	// CAM_AWB_ROT_CENTER_X
0xC934, 0xFFE0, 	// CAM_AWB_ROT_CENTER_Y
0xC936, 0x33 ,	// CAM_AWB_ROT_SIN
0xC937, 0x26 ,	// CAM_AWB_ROT_COS
0xC938, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_0
0xC93A, 0x0047, 	// CAM_AWB_WEIGHT_TABLE_1
0xC93C, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_2
0xC93E, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_3
0xC93E, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_3
0xC940, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_4
0xC942, 0x0022, 	// CAM_AWB_WEIGHT_TABLE_5
0xC944, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_6
0xC946, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_7
0xC948, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_8
0xC94A, 0x0002, 	// CAM_AWB_WEIGHT_TABLE_9
0xC94C, 0x3000, 	// CAM_AWB_WEIGHT_TABLE_10
0xC94E, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_11
0xC950, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_12
0xC952, 0x0123, 	// CAM_AWB_WEIGHT_TABLE_13
0xC954, 0x2000, 	// CAM_AWB_WEIGHT_TABLE_14
0xC956, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_15
0xC958, 0x0150, 	// CAM_AWB_WEIGHT_TABLE_16
0xC95A, 0x5300, 	// CAM_AWB_WEIGHT_TABLE_17
0xC95C, 0x1112, 	// CAM_AWB_WEIGHT_TABLE_18
0xC95E, 0x2010, 	// CAM_AWB_WEIGHT_TABLE_19
0xC960, 0x5574, 	// CAM_AWB_WEIGHT_TABLE_20
0xC962, 0x5000, 	// CAM_AWB_WEIGHT_TABLE_21
0xC964, 0x0202, 	// CAM_AWB_WEIGHT_TABLE_22
0xC966, 0x5300, 	// CAM_AWB_WEIGHT_TABLE_23
0xC968, 0x0371, 	// CAM_AWB_WEIGHT_TABLE_24
0xC96A, 0x0400, 	// CAM_AWB_WEIGHT_TABLE_25
0xC96C, 0x0002, 	// CAM_AWB_WEIGHT_TABLE_26
0xC96E, 0x2000, 	// CAM_AWB_WEIGHT_TABLE_27
0xC970, 0x0023, 	// CAM_AWB_WEIGHT_TABLE_28
0xC972, 0x0330, 	// CAM_AWB_WEIGHT_TABLE_29
0xC974, 0x0001, 	// CAM_AWB_WEIGHT_TABLE_30
0xC976, 0x0000, 	// CAM_AWB_WEIGHT_TABLE_31
0xCC02, 0x0083, 	// SENSOR_MGR_MODE
0xC88C, 0x0080, 	// CAM_CPIPE_CONTROL_FIRST_BLACK_LEVEL
0xC84A, 0x0BA0, 	// CAM_HDR_MC_CTRL_S1_THRESHOLD
0xC84C, 0x0FA0, 	// CAM_HDR_MC_CTRL_S2_THRESHOLD
0xC84E, 0x0800, 	// CAM_HDR_MC_CTRL_S12_RANGE
0xCA0C, 0xF8C0, 	// CAM_LL_BM_OFFSET
0xC846, 0x0000, 	// CAM_SENSOR_CONTROL_READ_MODE*****************
0xCAE8, 0x0010, 	// CAM_OUTPUT_FORMAT_YUV
0x3210, 0x0EB0, 	// COLOR_PIPELINE_CONTROL
0xBC02, 0x03C5, 	// LL_MODE
0xA802, 0x001C, 	// AE_TRACK_MODE
0xA812, 0x08 ,	// AE_TRACK_ADAPT_THRESH
0xA81C, 0x8C ,	// AE_TRACK_MIN_GAIN_GATE
0xC8CE, 0x0035, 	// RESERVED_CAM_CE
0xC8CA, 0x0030, 	// CAM_AET_AE_MIN_VIRT_AGAIN
0xC8CC, 0x0180, 	// CAM_AET_AE_MAX_VIRT_AGAIN
0xC8C6, 0x008C, 	// CAM_AET_AE_MIN_VIRT_DGAIN
0xC8C8, 0x03FF, 	// CAM_AET_AE_MAX_VIRT_DGAIN
0xC8BE, 0x0000, 	// CAM_AET_BLACK_CLIPPING_TARGET
0xA83C, 0x03E6, 	// RESERVED_AE_TRACK_3C
0xA83E, 0x0300, 	// RESERVED_AE_TRACK_3E
0xA840, 0x0133, 	// RESERVED_AE_TRACK_40
0xC988, 0x0E17, 	// CAM_ALTM_MODE
0x2402, 0x0008, 	// RESERVED_CPIPE_ALTM_REGS_2402
0xBCBE, 0xFFFF, 	// RESERVED_LL_BE
0xBCC0, 0x00C8, 	// RESERVED_LL_C0
0xBCBA, 0x0010, 	// RESERVED_LL_BA
0xBCBC, 0x0017, 	// RESERVED_LL_BC
0xBCC2, 0x0000, 	// LL_ALTM_LMIN_STATS_THRESHOLD
0xBCC4, 0x003B, 	// LL_ALTM_LMAX_STATS_THRESHOLD
0xC9CC, 0xFD00, 	// CAM_ALTM_LOWLIGHT_DARK_BM
0xC9CE, 0x0100, 	// CAM_ALTM_LOWLIGHT_BRIGHT_BM
0xC99A, 0x0600, 	// CAM_ALTM_DARK_BM
0xC99C, 0x0B00, 	// CAM_ALTM_BRIGHT_BM
0xC9A0, 0x00C8, 	// CAM_ALTM_SHARPNESS_DARK_BM
0xC9A2, 0x0B54, 	// CAM_ALTM_SHARPNESS_BRIGHT_BM
0x2414, 0x0BA0, 	// RESERVED_CPIPE_ALTM_REGS_2414
0x2416, 0x0FA0, 	// RESERVED_CPIPE_ALTM_REGS_2416
0x2418, 0xC350, 	// RESERVED_CPIPE_ALTM_REGS_2418
0x241A, 0xFA00, 	// RESERVED_CPIPE_ALTM_REGS_241A
0x241C, 0x0005, 	// RESERVED_CPIPE_ALTM_REGS_241C
0x241E, 0x0050, 	// RESERVED_CPIPE_ALTM_REGS_241E
0x2420, 0x00A5, 	// RESERVED_CPIPE_ALTM_REGS_2420
0x2422, 0x00A5, 	// RESERVED_CPIPE_ALTM_REGS_2422
0x2424, 0x00A5, 	// RESERVED_CPIPE_ALTM_REGS_2424
0x2426, 0x0001, 	// RESERVED_CPIPE_ALTM_REGS_2426
0xC996, 0x03E8, 	// CAM_ALTM_K1_MIN
0xC998, 0x03E8, 	// CAM_ALTM_K1_MAX
0xC98A, 0x000F, 	// CAM_ALTM_KEY_K0
0xC9E6, 0x0AF0, 	// CAM_ALTM_LA_MIN
0xCA2A, 0x32 ,	// CAM_LL_DEMOSAIC_HIGH
0xCA2B, 0x05 ,	// CAM_LL_DEMOSAIC_LOW
0xCA2E, 0x32 ,	// CAM_LL_AP_THRESH_HIGH
0xCA2F, 0x0A ,	// CAM_LL_AP_THRESH_LOW
0x3222, 0x0912, 	// GRB_POS_THRESHOLDS
0x3224, 0x0612, 	// GRB_NEG_THRESHOLDS
0xCAB4, 0x0000, 	// CAM_LL_CK_2_SNR
0xCAAE, 0x0022, 	// RESERVED_CAM_2AE
0x3414, 0x3700, 	// HUE11_Q3Q4
0x3408, 0x3700, 	// HUE5_Q1Q2
0x340C, 0x2A00, 	// HUE7_Q1Q2
0x3412, 0x0400, 	// HUE10_Q3Q4
0x3416, 0x0036, 	// HUE12_Q3Q4
0x341E, 0x0004, 	// HUE16_Q3Q4
0x3420, 0x2A3B, 	// HUE17_Q3Q4
0x341A, 0x0A00, 	// HUE14_Q3Q4
0x3400, 0x0800, 	// HUE1_Q1Q2
0x3402, 0x073B, 	// HUE2_Q1Q2
0x3406, 0x0500, 	// HUE4_Q1Q2
0x3404, 0x3E1E, 	// HUE3_Q1Q2
0x3454, 0x0004, 	// PCR_COLOR_GAIN7_REGION_7
0x3432, 0x000B, 	// PCR_COLOR_GAIN2_REGION_29
0x3452, 0x000B, 	// PCR_COLOR_GAIN6_REGION_33
0x345A, 0x000B, 	// PCR_COLOR_GAIN7_REGION_34
0x3462, 0x0000, 	// PCR_COLOR_GAIN8_REGION_35
0x344A, 0x0007, 	// PCR_COLOR_GAIN5_REGION_32
0x342E, 0x0006, 	// PCR_COLOR_GAIN2_REGION_11
0xCA20, 0x0100, 	// CAM_LL_DARK_BM
0xCA22, 0x0800, 	// CAM_LL_BRIGHT_BM
0xCA24, 0x0C80, 	// CAM_LL_HIGH_GM
0xCA26, 0x002D, 	// CAM_LL_LOW_GM
0xCA78, 0x0030, 	// CAM_LL_NR_LUT_0_GAIN
0xCA80, 0x0056, 	// CAM_LL_NR_LUT_1_GAIN
0xCA88, 0x0100, 	// CAM_LL_NR_LUT_2_GAIN
0xCA90, 0x0200, 	// CAM_LL_NR_LUT_3_GAIN
0xCA7A, 0x002D, 	// CAM_LL_NR_LUT_0_SIGMA
0xCA7C, 0x007D, 	// CAM_LL_NR_LUT_0_K0
0xCA82, 0x0050, 	// CAM_LL_NR_LUT_1_SIGMA
0xCA84, 0x007D, 	// CAM_LL_NR_LUT_1_K0
0xCA8A, 0x00B8, 	// CAM_LL_NR_LUT_2_SIGMA
0xCA8C, 0x007D, 	// CAM_LL_NR_LUT_2_K0
0xCA92, 0x0173, 	// CAM_LL_NR_LUT_3_SIGMA
0xCA94, 0x007D, 	// CAM_LL_NR_LUT_3_K0
0xCB20, 0x002D, 	// CAM_LL2_NR_LUT_T2_0_SIGMA
0xCB22, 0x007D, 	// CAM_LL2_NR_LUT_T2_0_K0
0xCB24, 0x0050, 	// CAM_LL2_NR_LUT_T2_1_SIGMA
0xCB26, 0x007D, 	// CAM_LL2_NR_LUT_T2_1_K0
0xCB28, 0x00B8, 	// CAM_LL2_NR_LUT_T2_2_SIGMA
0xCB2A, 0x007D, 	// CAM_LL2_NR_LUT_T2_2_K0
0xCB2C, 0x0180, 	// CAM_LL2_NR_LUT_T2_3_SIGMA
0xCB2E, 0x007D, 	// CAM_LL2_NR_LUT_T2_3_K0
0xCB40, 0x0000,
0xCB42, 0x07D0, 	// CAM_LL2_NR_TRANS_PT_S1
0xCB44, 0x0000,
0xCB46, 0x0DAC, 	// CAM_LL2_NR_TRANS_PT_S2
0xCA70, 0x0003, 	// CAM_LL_ADACD_GR_WEIGHTS_STRENGTH_LOW
0xCA72, 0x0003, 	// CAM_LL_ADACD_GR_WEIGHTS_STRENGTH_HIGH
0xCA74, 0x03E8, 	// CAM_LL_ADACD_GR_WEIGHTS_LOW_SNR
0xCA76, 0x0D00, 	// CAM_LL_ADACD_GR_WEIGHTS_HIGH_SNR
0xCA42, 0x02 ,	// CAM_LL_SDC_DP_STRENGTH_DARK
0xCA43, 0x16 ,	// CAM_LL_SDC_DP_STRENGTH_BRIGHT
0xCA48, 0x02 ,	// CAM_LL_SDC_HP_STRENGTH_DARK
0xCA49, 0x16 ,	// CAM_LL_SDC_HP_STRENGTH_BRIGHT
0xCA4E, 0x14 ,	// CAM_LL_SDC_CROSSFACTOR_STRENGTH_DARK
0xCA4F, 0x04 ,	// CAM_LL_SDC_CROSSFACTOR_STRENGTH_BRIGHT
0xCA5E, 0x01 ,	// CAM_LL_CDC_DP_STRENGTH_DARK
0xCA5F, 0x16 ,	// CAM_LL_CDC_DP_STRENGTH_BRIGHT
0xCA64, 0x01 ,	// CAM_LL_CDC_HP_STRENGTH_DARK
0xCA65, 0x16 ,	// CAM_LL_CDC_HP_STRENGTH_BRIGHT
0xCA6A, 0x1E ,	// CAM_LL_CDC_CROSSFACTOR_STRENGTH_DARK
0xCA6B, 0x05 ,	// CAM_LL_CDC_CROSSFACTOR_STRENGTH_BRIGHT
0xBC0A, 0x0000, 	// LL_GAMMA_CONTRAST_CURVE_0
0xBC0C, 0x000A, 	// LL_GAMMA_CONTRAST_CURVE_1
0xBC0E, 0x000B, 	// LL_GAMMA_CONTRAST_CURVE_2
0xBC10, 0x001A, 	// LL_GAMMA_CONTRAST_CURVE_3
0xBC12, 0x0027, 	// LL_GAMMA_CONTRAST_CURVE_4
0xBC14, 0x0032, 	// LL_GAMMA_CONTRAST_CURVE_5
0xBC16, 0x003D, 	// LL_GAMMA_CONTRAST_CURVE_6
0xBC18, 0x0046, 	// LL_GAMMA_CONTRAST_CURVE_7
0xBC1A, 0x004F, 	// LL_GAMMA_CONTRAST_CURVE_8
0xBC1C, 0x005F, 	// LL_GAMMA_CONTRAST_CURVE_9
0xBC1E, 0x006D, 	// LL_GAMMA_CONTRAST_CURVE_10
0xBC20, 0x007A, 	// LL_GAMMA_CONTRAST_CURVE_11
0xBC22, 0x0087, 	// LL_GAMMA_CONTRAST_CURVE_12
0xBC24, 0x009D, 	// LL_GAMMA_CONTRAST_CURVE_13
0xBC26, 0x00B1, 	// LL_GAMMA_CONTRAST_CURVE_14
0xBC28, 0x00C4, 	// LL_GAMMA_CONTRAST_CURVE_15
0xBC2A, 0x00D6, 	// LL_GAMMA_CONTRAST_CURVE_16
0xBC2C, 0x00F5, 	// LL_GAMMA_CONTRAST_CURVE_17
0xBC2E, 0x0112, 	// LL_GAMMA_CONTRAST_CURVE_18
0xBC30, 0x012D, 	// LL_GAMMA_CONTRAST_CURVE_19
0xBC32, 0x0145, 	// LL_GAMMA_CONTRAST_CURVE_20
0xBC34, 0x0172, 	// LL_GAMMA_CONTRAST_CURVE_21
0xBC36, 0x019B, 	// LL_GAMMA_CONTRAST_CURVE_22
0xBC38, 0x01C1, 	// LL_GAMMA_CONTRAST_CURVE_23
0xBC3A, 0x01E3, 	// LL_GAMMA_CONTRAST_CURVE_24
0xBC3C, 0x0223, 	// LL_GAMMA_CONTRAST_CURVE_25
0xBC3E, 0x025D, 	// LL_GAMMA_CONTRAST_CURVE_26
0xBC40, 0x0292, 	// LL_GAMMA_CONTRAST_CURVE_27
0xBC42, 0x02C3, 	// LL_GAMMA_CONTRAST_CURVE_28
0xBC44, 0x031D, 	// LL_GAMMA_CONTRAST_CURVE_29
0xBC46, 0x036F, 	// LL_GAMMA_CONTRAST_CURVE_30
0xBC48, 0x03B9, 	// LL_GAMMA_CONTRAST_CURVE_31
0xBC4A, 0x03FF, 	// LL_GAMMA_CONTRAST_CURVE_32
0xBC4C, 0x0000, 	// LL_GAMMA_NRCURVE_0
0xBC4E, 0x0002, 	// LL_GAMMA_NRCURVE_1
0xBC50, 0x0004, 	// LL_GAMMA_NRCURVE_2
0xBC52, 0x0007, 	// LL_GAMMA_NRCURVE_3
0xBC54, 0x0009, 	// LL_GAMMA_NRCURVE_4
0xBC56, 0x000B, 	// LL_GAMMA_NRCURVE_5
0xBC58, 0x000D, 	// LL_GAMMA_NRCURVE_6
0xBC5A, 0x000F, 	// LL_GAMMA_NRCURVE_7
0xBC5C, 0x0011, 	// LL_GAMMA_NRCURVE_8
0xBC5E, 0x0016, 	// LL_GAMMA_NRCURVE_9
0xBC60, 0x001A, 	// LL_GAMMA_NRCURVE_10
0xBC62, 0x001F, 	// LL_GAMMA_NRCURVE_11
0xBC64, 0x0023, 	// LL_GAMMA_NRCURVE_12
0xBC66, 0x002C, 	// LL_GAMMA_NRCURVE_13
0xBC68, 0x0034, 	// LL_GAMMA_NRCURVE_14
0xBC6A, 0x003D, 	// LL_GAMMA_NRCURVE_15
0xBC6C, 0x0046, 	// LL_GAMMA_NRCURVE_16
0xBC6E, 0x0057, 	// LL_GAMMA_NRCURVE_17
0xBC70, 0x0069, 	// LL_GAMMA_NRCURVE_18
0xBC72, 0x007A, 	// LL_GAMMA_NRCURVE_19
0xBC74, 0x008C, 	// LL_GAMMA_NRCURVE_20
0xBC76, 0x00AF, 	// LL_GAMMA_NRCURVE_21
0xBC78, 0x00D2, 	// LL_GAMMA_NRCURVE_22
0xBC7A, 0x00F5, 	// LL_GAMMA_NRCURVE_23
0xBC7C, 0x0118, 	// LL_GAMMA_NRCURVE_24
0xBC7E, 0x015E, 	// LL_GAMMA_NRCURVE_25
0xBC80, 0x01A4, 	// LL_GAMMA_NRCURVE_26
0xBC82, 0x01EA, 	// LL_GAMMA_NRCURVE_27
0xBC84, 0x022F, 	// LL_GAMMA_NRCURVE_28
0xBC86, 0x02B4, 	// LL_GAMMA_NRCURVE_29
0xBC88, 0x032B, 	// LL_GAMMA_NRCURVE_30
0xBC8A, 0x0399, 	// LL_GAMMA_NRCURVE_31
0xBC8C, 0x03FF, 	// LL_GAMMA_NRCURVE_32
0xCA30, 0x0B00, 	// CAM_LL_CONTRAST_BRIGHT_BM
0xCA32, 0x0100, 	// CAM_LL_CONTRAST_DARK_BM
0xCA08, 0x0001, 	// CAM_LL_MODE
0xC9C0, 0x0000, 	// CAM_ALTM_DARK_LO_GAMMA_BM
0xC9C2, 0x0800, 	// CAM_ALTM_BRIGHT_LO_GAMMA_BM
0xC9C8, 0x0080, 	// CAM_ALTM_DARK_HI_GAMMA_BM
0xC9CA, 0x0800, 	// CAM_ALTM_BRIGHT_HI_GAMMA_BM
0xC9BC, 0x0028, 	// CAM_ALTM_DARK_LO_GAMMA
0xC9BE, 0x0023, 	// CAM_ALTM_BRIGHT_LO_GAMMA
0xC9C4, 0x0046, 	// CAM_ALTM_DARK_HI_GAMMA
0xC9C6, 0x0046, 	// CAM_ALTM_BRIGHT_HI_GAMMA
0xC9A4, 0x0002, 	// CAM_ALTM_SHARPNESS_STRENGTH_DARK
0xC9A6, 0x001E, 	// CAM_ALTM_SHARPNESS_STRENGTH_BRIGHT
0xCA2C, 0x01 ,	// CAM_LL_AP_GAIN_DARK
0xCA2D, 0x03 ,	// CAM_LL_AP_GAIN_BRIGHT
0xCA9C, 0x0700, 	// CAM_LL_CK_0_SNR
0xCAA8, 0x0100, 	// CAM_LL_CK_1_SNR
0xCAA4, 0x01C0, 	// CAM_LL_CK_0_CHROMA_GAIN_HIGH
0xCAB0, 0x00B3, 	// CAM_LL_CK_1_CHROMA_GAIN_HIGH
0xCA28, 0x5A ,	// CAM_LL_DARK_SATURATION
0xA82C, 0x0880, 	// AE_TRACK_LOG_Y_TARGET_0
0xA82E, 0x095A, 	// AE_TRACK_LOG_Y_TARGET_1
0xA830, 0x0980, 	// AE_TRACK_LOG_Y_TARGET_2
0xA832, 0x0980, 	// AE_TRACK_LOG_Y_TARGET_3
0xA834, 0x0980, 	// AE_TRACK_LOG_Y_TARGET_4
0xA836, 0x0980, 	// AE_TRACK_LOG_Y_TARGET_5
0xA838, 0x0980, 	// AE_TRACK_LOG_Y_TARGET_6
0xA83A, 0x0980, 	// AE_TRACK_LOG_Y_TARGET_7
0xC88C, 0x0080, 	// CAM_CPIPE_CONTROL_FIRST_BLACK_LEVEL
0xB00C, 0x00 ,	// BLACKLEVEL_MAX_BLACK_LEVEL
0xC8BE, 0x0000, 	// CAM_AET_BLACK_CLIPPING_TARGET
0xB00D, 0x1E ,	// BLACKLEVEL_BLACK_LEVEL_DAMPING
0x0040, 0x8D00, 	// COMMAND_REGISTER
0x0040, 0x8D01, 	// COMMAND_REGISTER
0xFC00, 0x3028, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0200, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x2000, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8D06, 	// COMMAND_REGISTER
0x0040, 0x8D08, 	// COMMAND_REGISTER
0x0040, 0x8D02, 	// COMMAND_REGISTER
0xFC00, 0x0001, 	// CMD_HANDLER_PARAMS_POOL_0
0xFC02, 0x0101, 	// CMD_HANDLER_PARAMS_POOL_1
0xFC04, 0x0101, 	// CMD_HANDLER_PARAMS_POOL_2
0x0040, 0x8102, 	// COMMAND_REGISTER
0xFC00, 0x2800, 	// CMD_HANDLER_PARAMS_POOL_0
0x0040, 0x8100		// COMMAND_REGISTER

};

const unsigned short AP200_1080P30_8_16_Mask[]=
{
		0x0040, 0x100, 	// COMMAND_REGISTER
		0x098E, 0x100, 	// LOGICAL_ADDRESS_ACCESS [CMD_HANDLER_PARAMS_POOL_0]
		0xFC00, 0x100, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x154, 	// CMD_HANDLER_PARAMS_POOL_1
		0x0040, 0x106, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0x0982, 0x101, 	// ACCESS_CTL_STAT
		0x098A, 0x150, 	// PHYSICAL_ADDRESS_ACCESS
		0xC750, 0x1F1,
		0xC752, 0x1EA,
		0xC754, 0x140,
		0xC756, 0x1CF,
		0xC758, 0x1FF,
		0xC75A, 0x1A8,
		0xC75C, 0x1C4,
		0xC75E, 0x10B,
		0xC760, 0x1D1,
		0xC762, 0x104,
		0xC764, 0x104,
		0xC766, 0x1CF,
		0xC768, 0x101,
		0xC76A, 0x106,
		0xC76C, 0x140,
		0xC76E, 0x10F,
		0xC770, 0x111,
		0xC772, 0x100,
		0xC774, 0x1EE,
		0xC776, 0x160,
		0xC778, 0x104,
		0xC77A, 0x131,
		0xC77C, 0x140,
		0xC77E, 0x1E0,
		0xC780, 0x100,
		0xC782, 0x10A,
		0xC784, 0x1CF,
		0xC786, 0x1FF,
		0xC788, 0x19C,
		0xC78A, 0x135,
		0xC78C, 0x141,
		0xC78E, 0x100,
		0xC790, 0x102,
		0xC792, 0x140,
		0xC794, 0x1F1,
		0xC796, 0x194,
		0xC798, 0x1E0,
		0xC79A, 0x100,
		0xC79C, 0x1FF,
		0xC79E, 0x160,
		0xC7A0, 0x1FF,
		0xC7A2, 0x150,
		0x098E, 0x100, 	// LOGICAL_ADDRESS_ACCESS
		0xFC00, 0x130, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x140, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x103, 	// CMD_HANDLER_PARAMS_POOL_2
		0xFC06, 0x104, 	// CMD_HANDLER_PARAMS_POOL_3
		0xFC08, 0x154, 	// CMD_HANDLER_PARAMS_POOL_4
		0x0040, 0x102, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0x0040, 0x101, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0xFC00, 0x154, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x1CC, 	// CMD_HANDLER_PARAMS_POOL_1
		0x0040, 0x106, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0x0982, 0x101, 	// ACCESS_CTL_STAT
		0x098A, 0x1A4, 	// PHYSICAL_ADDRESS_ACCESS
		0xC7A4, 0x1F1,
		0xC7A6, 0x196,
		0xC7A8, 0x160,
		0xC7AA, 0x100,
		0xC7AC, 0x1A1,
		0xC7AE, 0x1CF,
		0xC7B0, 0x1FF,
		0xC7B2, 0x1A4,
		0xC7B4, 0x1C0,
		0xC7B6, 0x1EE,
		0xC7B8, 0x1E0,
		0xC7BA, 0x18B,
		0xC7BC, 0x1CF,
		0xC7BE, 0x101,
		0xC7C0, 0x12A,
		0xC7C2, 0x11B,
		0xC7C4, 0x151,
		0xC7C6, 0x120,
		0xC7C8, 0x180,
		0xC7CA, 0x1CC,
		0xC7CC, 0x162,
		0xC7CE, 0x107,
		0xC7D0, 0x102,
		0xC7D2, 0x160,
		0xC7D4, 0x100,
		0xC7D6, 0x1C0,
		0xC7D8, 0x102,
		0xC7DA, 0x140,
		0xC7DC, 0x1CD,
		0xC7DE, 0x160,
		0xC7E0, 0x1A1,
		0xC7E2, 0x1E0,
		0xC7E4, 0x1F1,
		0xC7E6, 0x14E,
		0xC7E8, 0x140,
		0xC7EA, 0x1E6,
		0xC7EC, 0x1C0,
		0xC7EE, 0x11A,
		0xC7F0, 0x10A,
		0xC7F2, 0x160,
		0xC7F4, 0x18A,
		0xC7F6, 0x10F,
		0xC7F8, 0x108,
		0xC7FA, 0x1CF,
		0xC7FC, 0x1FF,
		0xC7FE, 0x168,
		0xC800, 0x1CF,
		0xC802, 0x101,
		0xC804, 0x112,
		0xC806, 0x140,
		0xC808, 0x124,
		0xC80A, 0x180,
		0xC80C, 0x12D,
		0xC80E, 0x1CF,
		0xC810, 0x1FF,
		0xC812, 0x130,
		0xC814, 0x123,
		0xC816, 0x1CF,
		0xC818, 0x1FF,
		0xC81A, 0x1B0,
		0xC81C, 0x116,
		0xC81E, 0x17D,
		0xC820, 0x10A,
		0xC822, 0x12C,
		0xC824, 0x142,
		0xC826, 0x1C0,
		0xC828, 0x12F,
		0xC82A, 0x1FE,
		0xC82C, 0x160,
		0xC82E, 0x100,
		0xC830, 0x10A,
		0xC832, 0x11A,
		0xC834, 0x160,
		0xC836, 0x100,
		0xC838, 0x1CF,
		0xC83A, 0x100,
		0xC83C, 0x1FF,
		0xC83E, 0x150,
		0xC840, 0x1CA,
		0xC842, 0x145,
		0xC844, 0x1CF,
		0xC846, 0x1FF,
		0xC848, 0x1B4,
		0xC84A, 0x122,
		0xC84C, 0x1C0,
		0xC84E, 0x184,
		0xC850, 0x14A,
		0xC852, 0x130,
		0xC854, 0x1CA,
		0xC856, 0x18D,
		0xC858, 0x107,
		0xC85A, 0x1F8,
		0xC85C, 0x161,
		0xC85E, 0x19E,
		0xC860, 0x160,
		0xC862, 0x1E9,
		0xC864, 0x11F,
		0xC866, 0x135,
		0xC868, 0x140,
		0xC86A, 0x1E0,
		0xC86C, 0x150,
		0xC86E, 0x180,
		0xC870, 0x108,
		0xC872, 0x1CF,
		0xC874, 0x1FF,
		0xC876, 0x110,
		0xC878, 0x1F4,
		0xC87A, 0x181,
		0xC87C, 0x107,
		0xC87E, 0x125,
		0xC880, 0x151,
		0xC882, 0x109,
		0xC884, 0x1CF,
		0xC886, 0x1FF,
		0xC888, 0x1F4,
		0xC88A, 0x154,
		0xC88C, 0x12C,
		0xC88E, 0x141,
		0xC890, 0x141,
		0xC892, 0x143,
		0xC894, 0x12C,
		0xC896, 0x111,
		0xC898, 0x141,
		0xC89A, 0x141,
		0xC89C, 0x12C,
		0xC89E, 0x1E0,
		0xC8A0, 0x141,
		0xC8A2, 0x1C0,
		0xC8A4, 0x1F1,
		0xC8A6, 0x192,
		0xC8A8, 0x140,
		0xC8AA, 0x108,
		0xC8AC, 0x1F0,
		0xC8AE, 0x107,
		0xC8B0, 0x1CF,
		0xC8B2, 0x1FF,
		0xC8B4, 0x1B0,
		0xC8B6, 0x146,
		0xC8B8, 0x160,
		0xC8BA, 0x13D,
		0xC8BC, 0x108,
		0xC8BE, 0x100,
		0xC8C0, 0x121,
		0xC8C2, 0x116,
		0xC8C4, 0x1E0,
		0xC8C6, 0x147,
		0xC8C8, 0x108,
		0xC8CA, 0x1E9,
		0xC8CC, 0x156,
		0xC8CE, 0x1E0,
		0xC8D0, 0x108,
		0xC8D2, 0x108,
		0xC8D4, 0x182,
		0xC8D6, 0x11C,
		0xC8D8, 0x1C9,
		0xC8DA, 0x14A,
		0xC8DC, 0x1E0,
		0xC8DE, 0x108,
		0xC8E0, 0x1C1,
		0xC8E2, 0x160,
		0xC8E4, 0x1B8,
		0xC8E6, 0x1E0,
		0xC8E8, 0x1F1,
		0xC8EA, 0x14E,
		0xC8EC, 0x140,
		0xC8EE, 0x1CF,
		0xC8F0, 0x1FF,
		0xC8F2, 0x104,
		0xC8F4, 0x1C2,
		0xC8F6, 0x1C0,
		0xC8F8, 0x1CF,
		0xC8FA, 0x1FF,
		0xC8FC, 0x100,
		0xC8FE, 0x108,
		0xC900, 0x105,
		0xC902, 0x122,
		0xC904, 0x110,
		0xC906, 0x1D1,
		0xC908, 0x1A2,
		0xC90A, 0x113,
		0xC90C, 0x180,
		0xC90E, 0x1CC,
		0xC910, 0x162,
		0xC912, 0x10F,
		0xC914, 0x1CF,
		0xC916, 0x1FF,
		0xC918, 0x160,
		0xC91A, 0x1E3,
		0xC91C, 0x104,
		0xC91E, 0x1DE,
		0xC920, 0x120,
		0xC922, 0x100,
		0xC924, 0x101,
		0xC926, 0x10E,
		0xC928, 0x1C5,
		0xC92A, 0x100,
		0xC92C, 0x105,
		0xC92E, 0x1CF,
		0xC930, 0x100,
		0xC932, 0x17E,
		0xC934, 0x140,
		0xC936, 0x16D,
		0xC938, 0x140,
		0xC93A, 0x1E0,
		0xC93C, 0x100,
		0xC93E, 0x10A,
		0xC940, 0x1CF,
		0xC942, 0x1FF,
		0xC944, 0x158,
		0xC946, 0x135,
		0xC948, 0x141,
		0xC94A, 0x100,
		0xC94C, 0x102,
		0xC94E, 0x140,
		0xC950, 0x1F1,
		0xC952, 0x194,
		0xC954, 0x1E0,
		0xC956, 0x100,
		0xC958, 0x1FF,
		0xC95A, 0x164,
		0xC95C, 0x1FF,
		0xC95E, 0x1A4,
		0xC960, 0x1FF,
		0xC962, 0x198,
		0xC964, 0x1FF,
		0xC966, 0x1E4,
		0xC968, 0x1FF,
		0xC96A, 0x16C,
		0xC96C, 0x1FF,
		0xC96E, 0x1E8,
		0x098E, 0x100, 	// LOGICAL_ADDRESS_ACCESS
		0xFC00, 0x1EC, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x140, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x103, 	// CMD_HANDLER_PARAMS_POOL_2
		0xFC06, 0x104, 	// CMD_HANDLER_PARAMS_POOL_3
		0xFC08, 0x1CC, 	// CMD_HANDLER_PARAMS_POOL_4
		0x0040, 0x102, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0x0040, 0x101, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0xFC00, 0x120, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x15C, 	// CMD_HANDLER_PARAMS_POOL_1
		0x0040, 0x106, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0x0982, 0x101, 	// ACCESS_CTL_STAT
		0x098A, 0x170, 	// PHYSICAL_ADDRESS_ACCESS
		0xC970, 0x1F1,
		0xC972, 0x1CA,
		0xC974, 0x140,
		0xC976, 0x1CF,
		0xC978, 0x101,
		0xC97A, 0x196,
		0xC97C, 0x140,
		0xC97E, 0x10A,
		0xC980, 0x100,
		0xC982, 0x1CF,
		0xC984, 0x1FF,
		0xC986, 0x11C,
		0xC988, 0x107,
		0xC98A, 0x14A,
		0xC98C, 0x120,
		0xC98E, 0x112,
		0xC990, 0x16A,
		0xC992, 0x1E0,
		0xC994, 0x101,
		0xC996, 0x115,
		0xC998, 0x160,
		0xC99A, 0x1A9,
		0xC99C, 0x100,
		0xC99E, 0x10A,
		0xC9A0, 0x1CF,
		0xC9A2, 0x1FF,
		0xC9A4, 0x1C4,
		0xC9A6, 0x135,
		0xC9A8, 0x141,
		0xC9AA, 0x100,
		0xC9AC, 0x102,
		0xC9AE, 0x140,
		0xC9B0, 0x1F1,
		0xC9B2, 0x194,
		0xC9B4, 0x1CF,
		0xC9B6, 0x1FF,
		0xC9B8, 0x11C,
		0xC9BA, 0x108,
		0xC9BC, 0x112,
		0xC9BE, 0x1E0,
		0xC9C0, 0x100,
		0xC9C2, 0x100,
		0xC9C4, 0x1FF,
		0xC9C6, 0x1E4,
		0xC9C8, 0x1FF,
		0xC9CA, 0x170,
		0x098E, 0x100, 	// LOGICAL_ADDRESS_ACCESS
		0xFC00, 0x14C, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x140, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x103, 	// CMD_HANDLER_PARAMS_POOL_2
		0xFC06, 0x104, 	// CMD_HANDLER_PARAMS_POOL_3
		0xFC08, 0x15C, 	// CMD_HANDLER_PARAMS_POOL_4
		0x0040, 0x102, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0x0040, 0x101, 	// COMMAND_REGISTER
		//OLL  COM1ND_R,EGISTER::DOORBELL =>  0x00
		0xCC02, 0x193, 	// SENSOR_MGR_MODE
		0x0040, 0x100, 	// COMMAND_REGISTER
		0x0040, 0x101, 	// COMMAND_REGISTER
		0xFC00, 0x188, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x180, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x145,
		0xFC04, 0x172,
		0xFC06, 0x14A,
		0xFC08, 0x143,
		0xFC0A, 0x18E,
		0xFC0C, 0x12A,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x145,
		0xFC04, 0x17B,
		0xFC06, 0x1FF,
		0xFC08, 0x1FF,
		0xFC0A, 0x1EA,
		0xFC0C, 0x104,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x110,
		0xFC04, 0x105,
		0xFC06, 0x115,
		0xFC08, 0x12A,
		0xFC0A, 0x13D,
		0xFC0C, 0x145,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x12A,
		0xFC04, 0x12A,
		0xFC06, 0x13D,
		0xFC08, 0x13D,
		0xFC0A, 0x13D,
		0xFC0C, 0x12A,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x162,
		0xFC04, 0x128,
		0xFC06, 0x100,
		0xFC08, 0x12A,
		0xFC0A, 0x13D,
		0xFC0C, 0x17A,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x104,
		0xFC04, 0x12C,
		0xFC06, 0x18F,
		0xFC08, 0x143,
		0xFC0A, 0x12D,
		0xFC0C, 0x143,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x18E,
		0xFC04, 0x12A,
		0xFC06, 0x15C,
		0xFC08, 0x157,
		0xFC0A, 0x149,
		0xFC0C, 0x153,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x153,
		0xFC04, 0x14D,
		0xFC06, 0x1F8,
		0xFC08, 0x116,
		0xFC0A, 0x108,
		0xFC0C, 0x156,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x1B8,
		0xFC04, 0x198,
		0xFC06, 0x111,
		0xFC08, 0x104,
		0xFC0A, 0x184,
		0xFC0C, 0x194,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x15C,
		0xFC04, 0x15C,
		0xFC06, 0x145,
		0xFC08, 0x145,
		0xFC0A, 0x145,
		0xFC0C, 0x129,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x18E,
		0xFC04, 0x12A,
		0xFC06, 0x13E,
		0xFC08, 0x12A,
		0xFC0A, 0x13F,
		0xFC0C, 0x15C,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x129,
		0xFC04, 0x13F,
		0xFC06, 0x13E,
		0xFC08, 0x13E,
		0xFC0A, 0x15C,
		0xFC0C, 0x13F,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x13E,
		0xFC04, 0x15F,
		0xFC06, 0x190,
		0xFC08, 0x1F2,
		0xFC0A, 0x180,
		0xFC0C, 0x104,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x106,
		0xFC04, 0x129,
		0xFC06, 0x129,
		0xFC08, 0x15F,
		0xFC0A, 0x119,
		0xFC0C, 0x1FA,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x183,
		0xFC04, 0x1A8,
		0xFC06, 0x107,
		0xFC08, 0x1FB,
		0xFC0A, 0x129,
		0xFC0C, 0x188,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x13E,
		0xFC04, 0x12A,
		0xFC06, 0x15D,
		0xFC08, 0x192,
		0xFC0A, 0x110,
		0xFC0C, 0x104,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x116,
		0xFC04, 0x18D,
		0xFC06, 0x14D,
		0xFC08, 0x12B,
		0xFC0A, 0x14C,
		0xFC0C, 0x160,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x128,
		0xFC04, 0x1F2,
		0xFC06, 0x10F,
		0xFC08, 0x182,
		0xFC0A, 0x183,
		0xFC0C, 0x143,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x115,
		0xFC04, 0x14D,
		0xFC06, 0x12A,
		0xFC08, 0x145,
		0xFC0A, 0x18E,
		0xFC0C, 0x12A,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x13F,
		0xFC04, 0x112,
		0xFC06, 0x14A,
		0xFC08, 0x143,
		0xFC0A, 0x105,
		0xFC0C, 0x116,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x143,
		0xFC04, 0x15A,
		0xFC06, 0x116,
		0xFC08, 0x143,
		0xFC0A, 0x107,
		0xFC0C, 0x116,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x103,
		0xFC04, 0x19C,
		0xFC06, 0x178,
		0xFC08, 0x13F,
		0xFC0A, 0x12A,
		0xFC0C, 0x13E,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x145,
		0xFC04, 0x125,
		0xFC06, 0x106,
		0xFC08, 0x101,
		0xFC0A, 0x198,
		0xFC0C, 0x100,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x144,
		0xFC04, 0x103,
		0xFC06, 0x12D,
		0xFC08, 0x143,
		0xFC0A, 0x1A3,
		0xFC0C, 0x116,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x10D,
		0xFC04, 0x144,
		0xFC06, 0x110,
		0xFC08, 0x104,
		0xFC0A, 0x10D,
		0xFC0C, 0x116,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x144,
		0xFC04, 0x103,
		0xFC06, 0x1FC,
		0xFC08, 0x11D,
		0xFC0A, 0x160,
		0xFC0C, 0x154,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x15F,
		0xFC04, 0x105,
		0xFC06, 0x107,
		0xFC08, 0x12B,
		0xFC0A, 0x110,
		0xFC0C, 0x14C,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x155,
		0xFC04, 0x12B,
		0xFC06, 0x12B,
		0xFC08, 0x14E,
		0xFC0A, 0x129,
		0xFC0C, 0x129,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x129,
		0xFC04, 0x160,
		0xFC06, 0x119,
		0xFC08, 0x11B,
		0xFC0A, 0x148,
		0xFC0C, 0x108,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x188,
		0xFC04, 0x1B6,
		0xFC06, 0x101,
		0xFC08, 0x1F8,
		0xFC0A, 0x102,
		0xFC0C, 0x1FA,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x109,
		0xFC04, 0x11B,
		0xFC06, 0x1B2,
		0xFC08, 0x10C,
		0xFC0A, 0x102,
		0xFC0C, 0x113,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x113,
		0xFC04, 0x111,
		0xFC06, 0x10B,
		0xFC08, 0x12B,
		0xFC0A, 0x12A,
		0xFC0C, 0x12B,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x13E,
		0xFC04, 0x13F,
		0xFC06, 0x160,
		0xFC08, 0x1A2,
		0xFC0A, 0x1A3,
		0xFC0C, 0x14D,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x12A,
		0xFC04, 0x129,
		0xFC06, 0x145,
		0xFC08, 0x13E,
		0xFC0A, 0x12A,
		0xFC0C, 0x13E,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x145,
		0xFC04, 0x124,
		0xFC06, 0x108,
		0xFC08, 0x1FA,
		0xFC0A, 0x129,
		0xFC0C, 0x188,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x12B,
		0xFC04, 0x18B,
		0xFC06, 0x186,
		0xFC08, 0x148,
		0xFC0A, 0x14E,
		0xFC0C, 0x180,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x10B,
		0xFC04, 0x13F,
		0xFC06, 0x12A,
		0xFC08, 0x13F,
		0xFC0A, 0x129,
		0xFC0C, 0x129,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x129,
		0xFC04, 0x15C,
		0xFC06, 0x15F,
		0xFC08, 0x11C,
		0xFC0A, 0x1FA,
		0xFC0C, 0x158,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x100,
		0xFC04, 0x198,
		0xFC06, 0x106,
		0xFC08, 0x173,
		0xFC0A, 0x10A,
		0xFC0C, 0x116,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x143,
		0xFC04, 0x18E,
		0xFC06, 0x12A,
		0xFC08, 0x145,
		0xFC0A, 0x13F,
		0xFC0C, 0x12A,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x13E,
		0xFC04, 0x145,
		0xFC06, 0x13F,
		0xFC08, 0x18E,
		0xFC0A, 0x12A,
		0xFC0C, 0x18E,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x191,
		0xFC04, 0x19C,
		0xFC06, 0x19C,
		0xFC08, 0x144,
		0xFC0A, 0x116,
		0xFC0C, 0x17A,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x144,
		0xFC04, 0x14A,
		0xFC06, 0x143,
		0xFC08, 0x163,
		0xFC0A, 0x116,
		0xFC0C, 0x143,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x150,
		0xFC04, 0x116,
		0xFC06, 0x143,
		0xFC08, 0x166,
		0xFC0A, 0x116,
		0xFC0C, 0x103,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x19C,
		0xFC04, 0x178,
		0xFC06, 0x107,
		0xFC08, 0x19D,
		0xFC0A, 0x10C,
		0xFC0C, 0x144,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x110,
		0xFC04, 0x104,
		0xFC06, 0x10D,
		0xFC08, 0x116,
		0xFC0A, 0x13E,
		0xFC0C, 0x145,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x128,
		0xFC04, 0x106,
		0xFC06, 0x101,
		0xFC08, 0x198,
		0xFC0A, 0x100,
		0xFC0C, 0x160,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x186,
		0xFC02, 0x144,
		0xFC04, 0x12C,
		0xFC06, 0x100,
		0xFC08, 0x198,
		0xFC0A, 0x100,
		0xFC0C, 0x160,
		0xFC0E, 0x100,
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0x0040, 0x102, 	// COMMAND_REGISTER
		0x0040, 0x101, 	// COMMAND_REGISTER
		0xCCCC, 0x1 ,	// RESERVED_SENSOR_MGR_CC
		0x0040, 0x100, 	// COMMAND_REGISTER
		0x0040, 0x101, 	// COMMAND_REGISTER
		0xFC00, 0x1D6, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x134, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x136, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x100, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x10C, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x101, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x10E, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x103, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x110, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x105, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x104, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x10B, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1FE, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x100, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1D8, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x17B, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1DC, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x19B, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1DA, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x19B, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x192, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x100, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1EC, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x11C, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1BA, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x177, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1F6, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x1A7, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x144, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x104, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1D0, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x1FF, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1D4, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x103, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1FE, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x100, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1E2, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x188, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1E4, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x166, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1E6, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x122, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1E0, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x142, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0xFC00, 0x1F0, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x112, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0x0040, 0x102, 	// COMMAND_REGISTER
		0xCAC8, 0x1 ,	// CAM_SYSCTL_PLL_CONTROL
		0xCACA, 0x12F, 	// CAM_SYSCTL_PLL_DIVIDER_M_N_1_CLK
		0xCACE, 0x10E, 	// CAM_SYSCTL_PLL_DIVIDER_M_N_NET
		0xCAD0, 0x133, 	// CAM_SYSCTL_PLL_DIVIDER_P_1_CLK
		0xCAD4, 0x11F, 	// CAM_SYSCTL_PLL_DIVIDER_P_NET
		0xCAD4, 0x11F, 	// CAM_SYSCTL_PLL_DIVIDER_P_NET
		0xCAD8, 0x100,
		0xCADA, 0x100, 	// CAM_SYSCTL_PLL_FRACTION_1_CLK
		0xC806, 0x10C, 	// CAM_SENSOR_CFG_X_ADDR_START
		0xC80A, 0x18B, 	// CAM_SENSOR_CFG_X_ADDR_END
		0xC804, 0x100, 	// CAM_SENSOR_CFG_Y_ADDR_START
		0xC808, 0x137, 	// CAM_SENSOR_CFG_Y_ADDR_END
		0xC838, 0x102,
		0xC83A, 0x11B, 	// CAM_SENSOR_CONTROL_EXTERNAL_PLL
		0xC840, 0x10C, 	// CAM_SENSOR_CONTROL_EXTERNAL_OUTPUT_CLK_DIV
		0xC844, 0x102, 	// CAM_SENSOR_CONTROL_OPERATION_MODE
		0xC844, 0x101, 	// CAM_SENSOR_CONTROL_OPERATION_MODE
		0xC80C, 0x1BA,
		0xC80E, 0x174, 	// CAM_SENSOR_CFG_PIXCLK
		0xC814, 0x19E, 	// CAM_SENSOR_CFG_FRAME_LENGTH_LINES
		0xC816, 0x1BC, 	// CAM_SENSOR_CFG_LINE_LENGTH_PCK
		0xC846, 0x102, 	// CAM_SENSOR_CONTROL_READ_MODE
		0xC890, 0x1 ,	// CAM_MODE_SELECT
		0xC8A0, 0x100, 	// CAM_CROP_WINDOW_XOFFSET
		0xC8A2, 0x100, 	// CAM_CROP_WINDOW_YOFFSET
		0xC8A4, 0x180, 	// CAM_CROP_WINDOW_WIDTH
		0xC8A6, 0x138, 	// CAM_CROP_WINDOW_HEIGHT
		0xC9F8, 0x100, 	// CAM_STAT_AE_ALTM_FD_WINDOW_X_OFFSET
		0xC9FA, 0x100, 	// CAM_STAT_AE_ALTM_FD_WINDOW_Y_OFFSET
		0xC9FC, 0x180, 	// CAM_STAT_AE_ALTM_FD_WINDOW_WIDTH
		0xC9FE, 0x138, 	// CAM_STAT_AE_ALTM_FD_WINDOW_HEIGHT
		0xCA00, 0x100, 	// CAM_STAT_AWB_CLIP_WINDOW_X_OFFSET
		0xCA02, 0x100, 	// CAM_STAT_AWB_CLIP_WINDOW_Y_OFFSET
		0xCA04, 0x180, 	// CAM_STAT_AWB_CLIP_WINDOW_WIDTH
		0xCA06, 0x138, 	// CAM_STAT_AWB_CLIP_WINDOW_HEIGHT
		0xCAE4, 0x180, 	// CAM_OUTPUT_WIDTH
		0xCAE6, 0x138, 	// CAM_OUTPUT_HEIGHT
		0xCAE8, 0x111, 	// CAM_OUTPUT_FORMAT_YUV
		0xCAE8, 0x111, 	// CAM_OUTPUT_FORMAT_YUV
		0xCAEA, 0x1 ,	// CAM_OUTPUT_FORMAT
		0xCAEB, 0x1 ,	// CAM_OUTPUT_FORMAT_BAYER_PATH
		0xCAF4, 0x19F, 	// CAM_OUTPUT_COMPRESSED_BIT_RATE_8K
		0xCAF8, 0x1 ,	// CAM_OUTPUT_H264_CONTROL
		0xCAFC, 0x101, 	// CAM_PORT_PARALLEL_CONTROL
		0xCAFC, 0x101, 	// CAM_PORT_PARALLEL_CONTROL
		0xCAFC, 0x101, 	// CAM_PORT_PARALLEL_CONTROL
		0xCAFC, 0x101, 	// CAM_PORT_PARALLEL_CONTROL
		0xCAFC, 0x101, 	// CAM_PORT_PARALLEL_CONTROL
		0xCAFC, 0x101, 	// CAM_PORT_PARALLEL_CONTROL
		0xCAFC, 0x101, 	// CAM_PORT_PARALLEL_CONTROL
		0xCAFC, 0x101, 	// CAM_PORT_PARALLEL_CONTROL
		0xCAFE, 0x1BC, 	// CAM_PORT_CONST_LINE_LENGTH
		0xCB00, 0x100, 	// CAM_PORT_MAX_PACKET_PAYLOAD
		0x8C16, 0x1 ,	// NET_CFG_NET_CLOCK_FREQ
		0xCAC4, 0x100, 	// CAM_PGA_PGA_CONTROL
		0x3600, 0x1F0, 	// P_G1_P0Q0
		0x3602, 0x189, 	// P_G1_P0Q1
		0x3604, 0x170, 	// P_G1_P0Q2
		0x3606, 0x18D, 	// P_G1_P0Q3
		0x3608, 0x1EE, 	// P_G1_P0Q4
		0x360A, 0x1D0, 	// P_R_P0Q0
		0x360C, 0x10B, 	// P_R_P0Q1
		0x360E, 0x1B0, 	// P_R_P0Q2
		0x3610, 0x12D, 	// P_R_P0Q3
		0x3612, 0x1CF, 	// P_R_P0Q4
		0x3614, 0x1B0, 	// P_B_P0Q0
		0x3616, 0x149, 	// P_B_P0Q1
		0x3618, 0x150, 	// P_B_P0Q2
		0x361A, 0x14E, 	// P_B_P0Q3
		0x361C, 0x14E, 	// P_B_P0Q4
		0x361E, 0x1D0, 	// P_G2_P0Q0
		0x3620, 0x1E9, 	// P_G2_P0Q1
		0x3622, 0x110, 	// P_G2_P0Q2
		0x3624, 0x1ED, 	// P_G2_P0Q3
		0x3626, 0x1CF, 	// P_G2_P0Q4
		0x3628, 0x16B, 	// P_G1_P1Q0
		0x362A, 0x1C9, 	// P_G1_P1Q1
		0x362C, 0x150, 	// P_G1_P1Q2
		0x362E, 0x10F, 	// P_G1_P1Q3
		0x3630, 0x1F3, 	// P_G1_P1Q4
		0x3632, 0x18C, 	// P_R_P1Q0
		0x3634, 0x16A, 	// P_R_P1Q1
		0x3636, 0x190, 	// P_R_P1Q2
		0x3638, 0x12F, 	// P_R_P1Q3
		0x363A, 0x1D3, 	// P_R_P1Q4
		0x363C, 0x14A, 	// P_B_P1Q0
		0x363E, 0x18B, 	// P_B_P1Q1
		0x3640, 0x130, 	// P_B_P1Q2
		0x3642, 0x10F, 	// P_B_P1Q3
		0x3644, 0x113, 	// P_B_P1Q4
		0x3646, 0x14B, 	// P_G2_P1Q0
		0x3648, 0x10A, 	// P_G2_P1Q1
		0x364A, 0x1D0, 	// P_G2_P1Q2
		0x364C, 0x150, 	// P_G2_P1Q3
		0x364E, 0x1D3, 	// P_G2_P1Q4
		0x3650, 0x190, 	// P_G1_P2Q0
		0x3652, 0x12F, 	// P_G1_P2Q1
		0x3654, 0x131, 	// P_G1_P2Q2
		0x3656, 0x112, 	// P_G1_P2Q3
		0x3658, 0x155, 	// P_G1_P2Q4
		0x365A, 0x130, 	// P_R_P2Q0
		0x365C, 0x1CF, 	// P_R_P2Q1
		0x365E, 0x191, 	// P_R_P2Q2
		0x3660, 0x192, 	// P_R_P2Q3
		0x3662, 0x175, 	// P_R_P2Q4
		0x3664, 0x190, 	// P_B_P2Q0
		0x3666, 0x18F, 	// P_B_P2Q1
		0x3668, 0x191, 	// P_B_P2Q2
		0x366A, 0x1B2, 	// P_B_P2Q3
		0x366C, 0x115, 	// P_B_P2Q4
		0x366E, 0x190, 	// P_G2_P2Q0
		0x3670, 0x10F, 	// P_G2_P2Q1
		0x3672, 0x111, 	// P_G2_P2Q2
		0x3674, 0x152, 	// P_G2_P2Q3
		0x3676, 0x135, 	// P_G2_P2Q4
		0x3678, 0x130, 	// P_G1_P3Q0
		0x367A, 0x192, 	// P_G1_P3Q1
		0x367C, 0x1B5, 	// P_G1_P3Q2
		0x367E, 0x195, 	// P_G1_P3Q3
		0x3680, 0x138, 	// P_G1_P3Q4
		0x3682, 0x150, 	// P_R_P3Q0
		0x3684, 0x132, 	// P_R_P3Q1
		0x3686, 0x155, 	// P_R_P3Q2
		0x3688, 0x155, 	// P_R_P3Q3
		0x368A, 0x178, 	// P_R_P3Q4
		0x368C, 0x1F0, 	// P_B_P3Q0
		0x368E, 0x132, 	// P_B_P3Q1
		0x3690, 0x1B5, 	// P_B_P3Q2
		0x3692, 0x175, 	// P_B_P3Q3
		0x3694, 0x138, 	// P_B_P3Q4
		0x3696, 0x150, 	// P_G2_P3Q0
		0x3698, 0x1B2, 	// P_G2_P3Q1
		0x369A, 0x135, 	// P_G2_P3Q2
		0x369C, 0x1F5, 	// P_G2_P3Q3
		0x369E, 0x198, 	// P_G2_P3Q4
		0x36A0, 0x1F2, 	// P_G1_P4Q0
		0x36A2, 0x1D2, 	// P_G1_P4Q1
		0x36A4, 0x1B7, 	// P_G1_P4Q2
		0x36A6, 0x175, 	// P_G1_P4Q3
		0x36A8, 0x15A, 	// P_G1_P4Q4
		0x36AA, 0x171, 	// P_R_P4Q0
		0x36AC, 0x132, 	// P_R_P4Q1
		0x36AE, 0x177, 	// P_R_P4Q2
		0x36B0, 0x1F5, 	// P_R_P4Q3
		0x36B2, 0x1BA, 	// P_R_P4Q4
		0x36B4, 0x1B2, 	// P_B_P4Q0
		0x36B6, 0x173, 	// P_B_P4Q1
		0x36B8, 0x177, 	// P_B_P4Q2
		0x36BA, 0x115, 	// P_B_P4Q3
		0x36BC, 0x1BA, 	// P_B_P4Q4
		0x36BE, 0x1B2, 	// P_G2_P4Q0
		0x36C0, 0x192, 	// P_G2_P4Q1
		0x36C2, 0x117, 	// P_G2_P4Q2
		0x36C4, 0x1B5, 	// P_G2_P4Q3
		0x36C6, 0x19A, 	// P_G2_P4Q4
		0x36C8, 0x18A, 	// CENTER_ROW
		0x36CA, 0x1BE, 	// CENTER_COLUMN
		0xCAC4, 0x101, 	// CAM_PGA_PGA_CONTROL
		0xC91E, 0x18C, 	// CAM_AWB_CCM_L_CTEMP
		0xC920, 0x1A0, 	// CAM_AWB_CCM_M_CTEMP
		0xC922, 0x164, 	// CAM_AWB_CCM_R_CTEMP
		0xC924, 0x1C4, 	// CAM_AWB_COLOR_TEMPERATURE_MIN
		0xC926, 0x164, 	// CAM_AWB_COLOR_TEMPERATURE_MAX
		0xC912, 0x15F, 	// CAM_AWB_CCM_L_RG_GAIN
		0xC914, 0x16D, 	// CAM_AWB_CCM_L_BG_GAIN
		0xC916, 0x1AF, 	// CAM_AWB_CCM_M_RG_GAIN
		0xC918, 0x148, 	// CAM_AWB_CCM_M_BG_GAIN
		0xC91A, 0x196, 	// CAM_AWB_CCM_R_RG_GAIN
		0xC91C, 0x1B4, 	// CAM_AWB_CCM_R_BG_GAIN
		0xC982, 0x1 ,	// CAM_AWB_K_R_L
		0xC983, 0x1 ,	// CAM_AWB_K_G_L
		0xC984, 0x1 ,	// CAM_AWB_K_B_L
		0xC985, 0x1 ,	// CAM_AWB_K_R_R
		0xC986, 0x1 ,	// CAM_AWB_K_G_R
		0xC987, 0x1 ,	// CAM_AWB_K_B_R
		0xC980, 0x150, 	// CAM_AWB_TINTS_CTEMP_THRESHOLD
		0xC8DC, 0x13E, 	// CAM_AWB_CCM_L_0
		0xC8DE, 0x1DB, 	// CAM_AWB_CCM_L_1
		0xC8E0, 0x1E7, 	// CAM_AWB_CCM_L_2
		0xC8E2, 0x175, 	// CAM_AWB_CCM_L_3
		0xC8E4, 0x1B8, 	// CAM_AWB_CCM_L_4
		0xC8E6, 0x1D2, 	// CAM_AWB_CCM_L_5
		0xC8E8, 0x152, 	// CAM_AWB_CCM_L_6
		0xC8EA, 0x11A, 	// CAM_AWB_CCM_L_7
		0xC8EC, 0x195, 	// CAM_AWB_CCM_L_8
		0xC8EE, 0x1B0, 	// CAM_AWB_CCM_M_0
		0xC8F0, 0x140, 	// CAM_AWB_CCM_M_1
		0xC8F2, 0x110, 	// CAM_AWB_CCM_M_2
		0xC8F4, 0x187, 	// CAM_AWB_CCM_M_3
		0xC8F6, 0x1A2, 	// CAM_AWB_CCM_M_4
		0xC8F8, 0x1D7, 	// CAM_AWB_CCM_M_5
		0xC8FA, 0x1D3, 	// CAM_AWB_CCM_M_6
		0xC8FC, 0x163, 	// CAM_AWB_CCM_M_7
		0xC8FE, 0x1CB, 	// CAM_AWB_CCM_M_8
		0xC900, 0x154, 	// CAM_AWB_CCM_R_0
		0xC902, 0x1CD, 	// CAM_AWB_CCM_R_1
		0xC904, 0x1DE, 	// CAM_AWB_CCM_R_2
		0xC906, 0x1B1, 	// CAM_AWB_CCM_R_3
		0xC908, 0x13B, 	// CAM_AWB_CCM_R_4
		0xC90A, 0x1EC, 	// CAM_AWB_CCM_R_5
		0xC90C, 0x1D9, 	// CAM_AWB_CCM_R_6
		0xC90E, 0x19C, 	// CAM_AWB_CCM_R_7
		0xC910, 0x18B, 	// CAM_AWB_CCM_R_8
		0xC97D, 0x1 ,	// CAM_AWB_MODE
		0xC92A, 0x120, 	// CAM_AWB_X_SHIFT
		0xC92C, 0x118, 	// CAM_AWB_Y_SHIFT
		0xC92E, 0x180, 	// CAM_AWB_RECIP_X_SCALE
		0xC930, 0x180, 	// CAM_AWB_RECIP_Y_SCALE
		0xC932, 0x105, 	// CAM_AWB_ROT_CENTER_X
		0xC934, 0x1E0, 	// CAM_AWB_ROT_CENTER_Y
		0xC936, 0x1 ,	// CAM_AWB_ROT_SIN
		0xC937, 0x1 ,	// CAM_AWB_ROT_COS
		0xC938, 0x100, 	// CAM_AWB_WEIGHT_TABLE_0
		0xC93A, 0x147, 	// CAM_AWB_WEIGHT_TABLE_1
		0xC93C, 0x100, 	// CAM_AWB_WEIGHT_TABLE_2
		0xC93E, 0x100, 	// CAM_AWB_WEIGHT_TABLE_3
		0xC93E, 0x100, 	// CAM_AWB_WEIGHT_TABLE_3
		0xC940, 0x100, 	// CAM_AWB_WEIGHT_TABLE_4
		0xC942, 0x122, 	// CAM_AWB_WEIGHT_TABLE_5
		0xC944, 0x100, 	// CAM_AWB_WEIGHT_TABLE_6
		0xC946, 0x100, 	// CAM_AWB_WEIGHT_TABLE_7
		0xC948, 0x100, 	// CAM_AWB_WEIGHT_TABLE_8
		0xC94A, 0x102, 	// CAM_AWB_WEIGHT_TABLE_9
		0xC94C, 0x100, 	// CAM_AWB_WEIGHT_TABLE_10
		0xC94E, 0x100, 	// CAM_AWB_WEIGHT_TABLE_11
		0xC950, 0x100, 	// CAM_AWB_WEIGHT_TABLE_12
		0xC952, 0x123, 	// CAM_AWB_WEIGHT_TABLE_13
		0xC954, 0x100, 	// CAM_AWB_WEIGHT_TABLE_14
		0xC956, 0x100, 	// CAM_AWB_WEIGHT_TABLE_15
		0xC958, 0x150, 	// CAM_AWB_WEIGHT_TABLE_16
		0xC95A, 0x100, 	// CAM_AWB_WEIGHT_TABLE_17
		0xC95C, 0x112, 	// CAM_AWB_WEIGHT_TABLE_18
		0xC95E, 0x110, 	// CAM_AWB_WEIGHT_TABLE_19
		0xC960, 0x174, 	// CAM_AWB_WEIGHT_TABLE_20
		0xC962, 0x100, 	// CAM_AWB_WEIGHT_TABLE_21
		0xC964, 0x102, 	// CAM_AWB_WEIGHT_TABLE_22
		0xC966, 0x100, 	// CAM_AWB_WEIGHT_TABLE_23
		0xC968, 0x171, 	// CAM_AWB_WEIGHT_TABLE_24
		0xC96A, 0x100, 	// CAM_AWB_WEIGHT_TABLE_25
		0xC96C, 0x102, 	// CAM_AWB_WEIGHT_TABLE_26
		0xC96E, 0x100, 	// CAM_AWB_WEIGHT_TABLE_27
		0xC970, 0x123, 	// CAM_AWB_WEIGHT_TABLE_28
		0xC972, 0x130, 	// CAM_AWB_WEIGHT_TABLE_29
		0xC974, 0x101, 	// CAM_AWB_WEIGHT_TABLE_30
		0xC976, 0x100, 	// CAM_AWB_WEIGHT_TABLE_31
		0xCC02, 0x183, 	// SENSOR_MGR_MODE
		0xC88C, 0x180, 	// CAM_CPIPE_CONTROL_FIRST_BLACK_LEVEL
		0xC84A, 0x1A0, 	// CAM_HDR_MC_CTRL_S1_THRESHOLD
		0xC84C, 0x1A0, 	// CAM_HDR_MC_CTRL_S2_THRESHOLD
		0xC84E, 0x100, 	// CAM_HDR_MC_CTRL_S12_RANGE
		0xCA0C, 0x1C0, 	// CAM_LL_BM_OFFSET
		0xC846, 0x102, 	// CAM_SENSOR_CONTROL_READ_MODE
		0xCAE8, 0x110, 	// CAM_OUTPUT_FORMAT_YUV
		0x3210, 0x1B0, 	// COLOR_PIPELINE_CONTROL
		0xBC02, 0x1C5, 	// LL_MODE
		0xA802, 0x11C, 	// AE_TRACK_MODE
		0xA812, 0x1 ,	// AE_TRACK_ADAPT_THRESH
		0xA81C, 0x1 ,	// AE_TRACK_MIN_GAIN_GATE
		0xC8CE, 0x135, 	// RESERVED_CAM_CE
		0xC8CA, 0x130, 	// CAM_AET_AE_MIN_VIRT_AGAIN
		0xC8CC, 0x180, 	// CAM_AET_AE_MAX_VIRT_AGAIN
		0xC8C6, 0x18C, 	// CAM_AET_AE_MIN_VIRT_DGAIN
		0xC8C8, 0x1FF, 	// CAM_AET_AE_MAX_VIRT_DGAIN
		0xC8BE, 0x100, 	// CAM_AET_BLACK_CLIPPING_TARGET
		0xA83C, 0x1E6, 	// RESERVED_AE_TRACK_3C
		0xA83E, 0x100, 	// RESERVED_AE_TRACK_3E
		0xA840, 0x133, 	// RESERVED_AE_TRACK_40
		0xC988, 0x117, 	// CAM_ALTM_MODE
		0x2402, 0x108, 	// RESERVED_CPIPE_ALTM_REGS_2402
		0xBCBE, 0x1FF, 	// RESERVED_LL_BE
		0xBCC0, 0x1C8, 	// RESERVED_LL_C0
		0xBCBA, 0x110, 	// RESERVED_LL_BA
		0xBCBC, 0x117, 	// RESERVED_LL_BC
		0xBCC2, 0x100, 	// LL_ALTM_LMIN_STATS_THRESHOLD
		0xBCC4, 0x13B, 	// LL_ALTM_LMAX_STATS_THRESHOLD
		0xC9CC, 0x100, 	// CAM_ALTM_LOWLIGHT_DARK_BM
		0xC9CE, 0x100, 	// CAM_ALTM_LOWLIGHT_BRIGHT_BM
		0xC99A, 0x100, 	// CAM_ALTM_DARK_BM
		0xC99C, 0x100, 	// CAM_ALTM_BRIGHT_BM
		0xC9A0, 0x1C8, 	// CAM_ALTM_SHARPNESS_DARK_BM
		0xC9A2, 0x154, 	// CAM_ALTM_SHARPNESS_BRIGHT_BM
		0x2414, 0x1A0, 	// RESERVED_CPIPE_ALTM_REGS_2414
		0x2416, 0x1A0, 	// RESERVED_CPIPE_ALTM_REGS_2416
		0x2418, 0x150, 	// RESERVED_CPIPE_ALTM_REGS_2418
		0x241A, 0x100, 	// RESERVED_CPIPE_ALTM_REGS_241A
		0x241C, 0x105, 	// RESERVED_CPIPE_ALTM_REGS_241C
		0x241E, 0x150, 	// RESERVED_CPIPE_ALTM_REGS_241E
		0x2420, 0x1A5, 	// RESERVED_CPIPE_ALTM_REGS_2420
		0x2422, 0x1A5, 	// RESERVED_CPIPE_ALTM_REGS_2422
		0x2424, 0x1A5, 	// RESERVED_CPIPE_ALTM_REGS_2424
		0x2426, 0x101, 	// RESERVED_CPIPE_ALTM_REGS_2426
		0xC996, 0x1E8, 	// CAM_ALTM_K1_MIN
		0xC998, 0x1E8, 	// CAM_ALTM_K1_MAX
		0xC98A, 0x10F, 	// CAM_ALTM_KEY_K0
		0xC9E6, 0x1F0, 	// CAM_ALTM_LA_MIN
		0xCA2A, 0x1 ,	// CAM_LL_DEMOSAIC_HIGH
		0xCA2B, 0x1 ,	// CAM_LL_DEMOSAIC_LOW
		0xCA2E, 0x1 ,	// CAM_LL_AP_THRESH_HIGH
		0xCA2F, 0x1 ,	// CAM_LL_AP_THRESH_LOW
		0x3222, 0x112, 	// GRB_POS_THRESHOLDS
		0x3224, 0x112, 	// GRB_NEG_THRESHOLDS
		0xCAB4, 0x100, 	// CAM_LL_CK_2_SNR
		0xCAAE, 0x122, 	// RESERVED_CAM_2AE
		0x3414, 0x100, 	// HUE11_Q3Q4
		0x3408, 0x100, 	// HUE5_Q1Q2
		0x340C, 0x100, 	// HUE7_Q1Q2
		0x3412, 0x100, 	// HUE10_Q3Q4
		0x3416, 0x136, 	// HUE12_Q3Q4
		0x341E, 0x104, 	// HUE16_Q3Q4
		0x3420, 0x13B, 	// HUE17_Q3Q4
		0x341A, 0x100, 	// HUE14_Q3Q4
		0x3400, 0x100, 	// HUE1_Q1Q2
		0x3402, 0x13B, 	// HUE2_Q1Q2
		0x3406, 0x100, 	// HUE4_Q1Q2
		0x3404, 0x11E, 	// HUE3_Q1Q2
		0x3454, 0x104, 	// PCR_COLOR_GAIN7_REGION_7
		0x3432, 0x10B, 	// PCR_COLOR_GAIN2_REGION_29
		0x3452, 0x10B, 	// PCR_COLOR_GAIN6_REGION_33
		0x345A, 0x10B, 	// PCR_COLOR_GAIN7_REGION_34
		0x3462, 0x100, 	// PCR_COLOR_GAIN8_REGION_35
		0x344A, 0x107, 	// PCR_COLOR_GAIN5_REGION_32
		0x342E, 0x106, 	// PCR_COLOR_GAIN2_REGION_11
		0xCA20, 0x100, 	// CAM_LL_DARK_BM
		0xCA22, 0x100, 	// CAM_LL_BRIGHT_BM
		0xCA24, 0x180, 	// CAM_LL_HIGH_GM
		0xCA26, 0x12D, 	// CAM_LL_LOW_GM
		0xCA78, 0x130, 	// CAM_LL_NR_LUT_0_GAIN
		0xCA80, 0x156, 	// CAM_LL_NR_LUT_1_GAIN
		0xCA88, 0x100, 	// CAM_LL_NR_LUT_2_GAIN
		0xCA90, 0x100, 	// CAM_LL_NR_LUT_3_GAIN
		0xCA7A, 0x12D, 	// CAM_LL_NR_LUT_0_SIGMA
		0xCA7C, 0x17D, 	// CAM_LL_NR_LUT_0_K0
		0xCA82, 0x150, 	// CAM_LL_NR_LUT_1_SIGMA
		0xCA84, 0x17D, 	// CAM_LL_NR_LUT_1_K0
		0xCA8A, 0x1B8, 	// CAM_LL_NR_LUT_2_SIGMA
		0xCA8C, 0x17D, 	// CAM_LL_NR_LUT_2_K0
		0xCA92, 0x173, 	// CAM_LL_NR_LUT_3_SIGMA
		0xCA94, 0x17D, 	// CAM_LL_NR_LUT_3_K0
		0xCB20, 0x12D, 	// CAM_LL2_NR_LUT_T2_0_SIGMA
		0xCB22, 0x17D, 	// CAM_LL2_NR_LUT_T2_0_K0
		0xCB24, 0x150, 	// CAM_LL2_NR_LUT_T2_1_SIGMA
		0xCB26, 0x17D, 	// CAM_LL2_NR_LUT_T2_1_K0
		0xCB28, 0x1B8, 	// CAM_LL2_NR_LUT_T2_2_SIGMA
		0xCB2A, 0x17D, 	// CAM_LL2_NR_LUT_T2_2_K0
		0xCB2C, 0x180, 	// CAM_LL2_NR_LUT_T2_3_SIGMA
		0xCB2E, 0x17D, 	// CAM_LL2_NR_LUT_T2_3_K0
		0xCB40, 0x100,
		0xCB42, 0x1D0, 	// CAM_LL2_NR_TRANS_PT_S1
		0xCB44, 0x100,
		0xCB46, 0x1AC, 	// CAM_LL2_NR_TRANS_PT_S2
		0xCA70, 0x103, 	// CAM_LL_ADACD_GR_WEIGHTS_STRENGTH_LOW
		0xCA72, 0x103, 	// CAM_LL_ADACD_GR_WEIGHTS_STRENGTH_HIGH
		0xCA74, 0x1E8, 	// CAM_LL_ADACD_GR_WEIGHTS_LOW_SNR
		0xCA76, 0x100, 	// CAM_LL_ADACD_GR_WEIGHTS_HIGH_SNR
		0xCA42, 0x1 ,	// CAM_LL_SDC_DP_STRENGTH_DARK
		0xCA43, 0x1 ,	// CAM_LL_SDC_DP_STRENGTH_BRIGHT
		0xCA48, 0x1 ,	// CAM_LL_SDC_HP_STRENGTH_DARK
		0xCA49, 0x1 ,	// CAM_LL_SDC_HP_STRENGTH_BRIGHT
		0xCA4E, 0x1 ,	// CAM_LL_SDC_CROSSFACTOR_STRENGTH_DARK
		0xCA4F, 0x1 ,	// CAM_LL_SDC_CROSSFACTOR_STRENGTH_BRIGHT
		0xCA5E, 0x1 ,	// CAM_LL_CDC_DP_STRENGTH_DARK
		0xCA5F, 0x1 ,	// CAM_LL_CDC_DP_STRENGTH_BRIGHT
		0xCA64, 0x1 ,	// CAM_LL_CDC_HP_STRENGTH_DARK
		0xCA65, 0x1 ,	// CAM_LL_CDC_HP_STRENGTH_BRIGHT
		0xCA6A, 0x1 ,	// CAM_LL_CDC_CROSSFACTOR_STRENGTH_DARK
		0xCA6B, 0x1 ,	// CAM_LL_CDC_CROSSFACTOR_STRENGTH_BRIGHT
		0xBC0A, 0x100, 	// LL_GAMMA_CONTRAST_CURVE_0
		0xBC0C, 0x10A, 	// LL_GAMMA_CONTRAST_CURVE_1
		0xBC0E, 0x10B, 	// LL_GAMMA_CONTRAST_CURVE_2
		0xBC10, 0x11A, 	// LL_GAMMA_CONTRAST_CURVE_3
		0xBC12, 0x127, 	// LL_GAMMA_CONTRAST_CURVE_4
		0xBC14, 0x132, 	// LL_GAMMA_CONTRAST_CURVE_5
		0xBC16, 0x13D, 	// LL_GAMMA_CONTRAST_CURVE_6
		0xBC18, 0x146, 	// LL_GAMMA_CONTRAST_CURVE_7
		0xBC1A, 0x14F, 	// LL_GAMMA_CONTRAST_CURVE_8
		0xBC1C, 0x15F, 	// LL_GAMMA_CONTRAST_CURVE_9
		0xBC1E, 0x16D, 	// LL_GAMMA_CONTRAST_CURVE_10
		0xBC20, 0x17A, 	// LL_GAMMA_CONTRAST_CURVE_11
		0xBC22, 0x187, 	// LL_GAMMA_CONTRAST_CURVE_12
		0xBC24, 0x19D, 	// LL_GAMMA_CONTRAST_CURVE_13
		0xBC26, 0x1B1, 	// LL_GAMMA_CONTRAST_CURVE_14
		0xBC28, 0x1C4, 	// LL_GAMMA_CONTRAST_CURVE_15
		0xBC2A, 0x1D6, 	// LL_GAMMA_CONTRAST_CURVE_16
		0xBC2C, 0x1F5, 	// LL_GAMMA_CONTRAST_CURVE_17
		0xBC2E, 0x112, 	// LL_GAMMA_CONTRAST_CURVE_18
		0xBC30, 0x12D, 	// LL_GAMMA_CONTRAST_CURVE_19
		0xBC32, 0x145, 	// LL_GAMMA_CONTRAST_CURVE_20
		0xBC34, 0x172, 	// LL_GAMMA_CONTRAST_CURVE_21
		0xBC36, 0x19B, 	// LL_GAMMA_CONTRAST_CURVE_22
		0xBC38, 0x1C1, 	// LL_GAMMA_CONTRAST_CURVE_23
		0xBC3A, 0x1E3, 	// LL_GAMMA_CONTRAST_CURVE_24
		0xBC3C, 0x123, 	// LL_GAMMA_CONTRAST_CURVE_25
		0xBC3E, 0x15D, 	// LL_GAMMA_CONTRAST_CURVE_26
		0xBC40, 0x192, 	// LL_GAMMA_CONTRAST_CURVE_27
		0xBC42, 0x1C3, 	// LL_GAMMA_CONTRAST_CURVE_28
		0xBC44, 0x11D, 	// LL_GAMMA_CONTRAST_CURVE_29
		0xBC46, 0x16F, 	// LL_GAMMA_CONTRAST_CURVE_30
		0xBC48, 0x1B9, 	// LL_GAMMA_CONTRAST_CURVE_31
		0xBC4A, 0x1FF, 	// LL_GAMMA_CONTRAST_CURVE_32
		0xBC4C, 0x100, 	// LL_GAMMA_NRCURVE_0
		0xBC4E, 0x102, 	// LL_GAMMA_NRCURVE_1
		0xBC50, 0x104, 	// LL_GAMMA_NRCURVE_2
		0xBC52, 0x107, 	// LL_GAMMA_NRCURVE_3
		0xBC54, 0x109, 	// LL_GAMMA_NRCURVE_4
		0xBC56, 0x10B, 	// LL_GAMMA_NRCURVE_5
		0xBC58, 0x10D, 	// LL_GAMMA_NRCURVE_6
		0xBC5A, 0x10F, 	// LL_GAMMA_NRCURVE_7
		0xBC5C, 0x111, 	// LL_GAMMA_NRCURVE_8
		0xBC5E, 0x116, 	// LL_GAMMA_NRCURVE_9
		0xBC60, 0x11A, 	// LL_GAMMA_NRCURVE_10
		0xBC62, 0x11F, 	// LL_GAMMA_NRCURVE_11
		0xBC64, 0x123, 	// LL_GAMMA_NRCURVE_12
		0xBC66, 0x12C, 	// LL_GAMMA_NRCURVE_13
		0xBC68, 0x134, 	// LL_GAMMA_NRCURVE_14
		0xBC6A, 0x13D, 	// LL_GAMMA_NRCURVE_15
		0xBC6C, 0x146, 	// LL_GAMMA_NRCURVE_16
		0xBC6E, 0x157, 	// LL_GAMMA_NRCURVE_17
		0xBC70, 0x169, 	// LL_GAMMA_NRCURVE_18
		0xBC72, 0x17A, 	// LL_GAMMA_NRCURVE_19
		0xBC74, 0x18C, 	// LL_GAMMA_NRCURVE_20
		0xBC76, 0x1AF, 	// LL_GAMMA_NRCURVE_21
		0xBC78, 0x1D2, 	// LL_GAMMA_NRCURVE_22
		0xBC7A, 0x1F5, 	// LL_GAMMA_NRCURVE_23
		0xBC7C, 0x118, 	// LL_GAMMA_NRCURVE_24
		0xBC7E, 0x15E, 	// LL_GAMMA_NRCURVE_25
		0xBC80, 0x1A4, 	// LL_GAMMA_NRCURVE_26
		0xBC82, 0x1EA, 	// LL_GAMMA_NRCURVE_27
		0xBC84, 0x12F, 	// LL_GAMMA_NRCURVE_28
		0xBC86, 0x1B4, 	// LL_GAMMA_NRCURVE_29
		0xBC88, 0x12B, 	// LL_GAMMA_NRCURVE_30
		0xBC8A, 0x199, 	// LL_GAMMA_NRCURVE_31
		0xBC8C, 0x1FF, 	// LL_GAMMA_NRCURVE_32
		0xCA30, 0x100, 	// CAM_LL_CONTRAST_BRIGHT_BM
		0xCA32, 0x100, 	// CAM_LL_CONTRAST_DARK_BM
		0xCA08, 0x101, 	// CAM_LL_MODE
		0xC9C0, 0x100, 	// CAM_ALTM_DARK_LO_GAMMA_BM
		0xC9C2, 0x100, 	// CAM_ALTM_BRIGHT_LO_GAMMA_BM
		0xC9C8, 0x180, 	// CAM_ALTM_DARK_HI_GAMMA_BM
		0xC9CA, 0x100, 	// CAM_ALTM_BRIGHT_HI_GAMMA_BM
		0xC9BC, 0x128, 	// CAM_ALTM_DARK_LO_GAMMA
		0xC9BE, 0x123, 	// CAM_ALTM_BRIGHT_LO_GAMMA
		0xC9C4, 0x146, 	// CAM_ALTM_DARK_HI_GAMMA
		0xC9C6, 0x146, 	// CAM_ALTM_BRIGHT_HI_GAMMA
		0xC9A4, 0x102, 	// CAM_ALTM_SHARPNESS_STRENGTH_DARK
		0xC9A6, 0x11E, 	// CAM_ALTM_SHARPNESS_STRENGTH_BRIGHT
		0xCA2C, 0x1 ,	// CAM_LL_AP_GAIN_DARK
		0xCA2D, 0x1 ,	// CAM_LL_AP_GAIN_BRIGHT
		0xCA9C, 0x100, 	// CAM_LL_CK_0_SNR
		0xCAA8, 0x100, 	// CAM_LL_CK_1_SNR
		0xCAA4, 0x1C0, 	// CAM_LL_CK_0_CHROMA_GAIN_HIGH
		0xCAB0, 0x1B3, 	// CAM_LL_CK_1_CHROMA_GAIN_HIGH
		0xCA28, 0x1 ,	// CAM_LL_DARK_SATURATION
		0xA82C, 0x180, 	// AE_TRACK_LOG_Y_TARGET_0
		0xA82E, 0x15A, 	// AE_TRACK_LOG_Y_TARGET_1
		0xA830, 0x180, 	// AE_TRACK_LOG_Y_TARGET_2
		0xA832, 0x180, 	// AE_TRACK_LOG_Y_TARGET_3
		0xA834, 0x180, 	// AE_TRACK_LOG_Y_TARGET_4
		0xA836, 0x180, 	// AE_TRACK_LOG_Y_TARGET_5
		0xA838, 0x180, 	// AE_TRACK_LOG_Y_TARGET_6
		0xA83A, 0x180, 	// AE_TRACK_LOG_Y_TARGET_7
		0xC88C, 0x180, 	// CAM_CPIPE_CONTROL_FIRST_BLACK_LEVEL
		0xB00C, 0x1 ,	// BLACKLEVEL_MAX_BLACK_LEVEL
		0xC8BE, 0x100, 	// CAM_AET_BLACK_CLIPPING_TARGET
		0xB00D, 0x1 ,	// BLACKLEVEL_BLACK_LEVEL_DAMPING
		0x0040, 0x100, 	// COMMAND_REGISTER
		0x0040, 0x101, 	// COMMAND_REGISTER
		0xFC00, 0x128, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x100, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x100, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x106, 	// COMMAND_REGISTER
		0x0040, 0x108, 	// COMMAND_REGISTER
		0x0040, 0x102, 	// COMMAND_REGISTER
		0xFC00, 0x101, 	// CMD_HANDLER_PARAMS_POOL_0
		0xFC02, 0x101, 	// CMD_HANDLER_PARAMS_POOL_1
		0xFC04, 0x101, 	// CMD_HANDLER_PARAMS_POOL_2
		0x0040, 0x102, 	// COMMAND_REGISTER
		0xFC00, 0x100, 	// CMD_HANDLER_PARAMS_POOL_0
		0x0040, 0x100   	// COMMAND_REGISTER

};



static struct ap0202_mode_info ap0202_mode_info_data[AP0202_MODE_MAX + 1] = {
	{
		.mode = AP0202_MODE_1080P,
		.width = 1920,
		.height = 1080,
		.data = ap0202_1080p,
		.data_size = ARRAY_SIZE(ap0202_1080p)
	},

	{
		.mode = AP0202_MODE_MAX,
		.width = 1920,
		.height = 1080,
		.data = ap0202_1080p,
		.data_size = ARRAY_SIZE(ap0202_1080p)
	},

};


static int ap0202_regulators_enable(struct ap0202 *ap0202)
{
	int ret;

	ret = regulator_enable(ap0202->io_regulator);
	if (ret < 0) {
		dev_err(ap0202->dev, "set io voltage failed\n");
		return ret;
	}

	ret = regulator_enable(ap0202->core_regulator);
	if (ret) {
		dev_err(ap0202->dev, "set core voltage failed\n");
		goto err_disable_io;
	}

	ret = regulator_enable(ap0202->analog_regulator);
	if (ret) {
		dev_err(ap0202->dev, "set analog voltage failed\n");
		goto err_disable_core;
	}

	return 0;

err_disable_core:
	regulator_disable(ap0202->core_regulator);
err_disable_io:
	regulator_disable(ap0202->io_regulator);

	return ret;
}

static void ap0202_regulators_disable(struct ap0202 *ap0202)
{
	int ret;

	ret = regulator_disable(ap0202->analog_regulator);
	if (ret < 0)
		dev_err(ap0202->dev, "analog regulator disable failed\n");

	ret = regulator_disable(ap0202->core_regulator);
	if (ret < 0)
		dev_err(ap0202->dev, "core regulator disable failed\n");

	ret = regulator_disable(ap0202->io_regulator);
	if (ret < 0)
		dev_err(ap0202->dev, "io regulator disable failed\n");
}

static int ap0202_write_reg(struct ap0202 *ap0202, u16 reg, u16 val)
{
	int ret;
	
	u16 i2c_addr = ap0202->i2c_client->addr = 0x90;

	ret = msm_cci_ctrl16_write16(i2c_addr, reg, &val, 2);
	if (ret < 0)
		dev_err(ap0202->dev,
			"%s: write reg error %d on addr 0x%x: reg=0x%x, val=0x%x\n",
			__func__, ret, i2c_addr, reg, val);

	return ret;
}
static int ap0202_write_reg8(struct ap0202 *ap0202, u16 reg, u8 val)
{
	int ret;
	
	u16 i2c_addr = ap0202->i2c_client->addr = 0x90;

	ret = msm_cci_ctrl_write(i2c_addr, reg, &val, 1);
	if (ret < 0)
		dev_err(ap0202->dev,
			"%s: write reg error %d on addr 0x%x: reg=0x%x, val=0x%x\n",
			__func__, ret, i2c_addr, reg, val);

	return ret;
}

static int ap0202_read_reg(struct ap0202 *ap0202, u16 reg, u16 *val)
{
	u8 rev_buf[2];
	int ret;
	u16 i2c_addr = ap0202->i2c_client->addr = 0x90;

	ret = msm_cci_ctrl_read(i2c_addr, reg, rev_buf, 2);
	if (ret < 0) {
		dev_err(ap0202->dev,
			"%s: read reg error %d on addr 0x%x: reg=0x%x\n",
			__func__, ret, i2c_addr, reg);
		return ret;
	}

	*val = (rev_buf[0]<<8)|rev_buf[1];

	return 0;
}
static int toshiba_bridge_write_reg(struct ap0202 *ap0202, u16 reg, u16 val)
{
	int ret;

	u16 i2c_addr = ap0202->i2c_client->addr = 0x1C;
	
	ret = msm_cci_ctrl16_write16(i2c_addr, reg, &val, 1);
	if (ret < 0)
		dev_err(ap0202->dev,
			"%s: write reg error %d on addr 0x%x: reg=0x%x, val=0x%x\n",
			__func__, ret, i2c_addr, reg, val);

	return ret;
}
static int toshiba_bridge_write_reg32(struct ap0202 *ap0202, u16 reg, u32 val)
{
	int ret;
	u8 w_buf[2];

	u16 i2c_addr = ap0202->i2c_client->addr = 0x1C;

	
	ret = msm_cci_ctrl16_write32(i2c_addr, reg, &val, 2);
	if (ret < 0)
		dev_err(ap0202->dev,
			"%s: write reg error %d on addr 0x%x: reg=0x%x, val=0x%x\n",
			__func__, ret, i2c_addr, reg, val);

	return ret;
}

static int toshiba_bridge_read_reg(struct ap0202 *ap0202, u16 reg, u16 *val)
{
	u8 rev_buf[2];
	int ret;
	u16 i2c_addr = ap0202->i2c_client->addr = 0x1C;

	ret = msm_cci_ctrl_read(i2c_addr, reg, rev_buf, 2);
	if (ret < 0) {
		dev_err(ap0202->dev,
			"%s: read reg error %d on addr 0x%x: reg=0x%x\n",
			__func__, ret, i2c_addr, reg);
		return ret;
	}

	*val = (rev_buf[0]<<8)|rev_buf[1];

	return 0;
}

static int ap0202_init(struct ap0202 *ap0202,enum ap0202_mode mode)
{
		int ret;u16 i;
		
		uint32_t burst_add;
		
		for (i = 0; i < sizeof(ap0202_1080p)/sizeof(unsigned short) ; i=i+2)
		{
			 if(AP200_1080P30_8_16_Mask[i+1] > 0x01)
			 {
				ret = ap0202_write_reg(ap0202,ap0202_1080p[i],ap0202_1080p[i+1]);
				if(ret<0)
					{
						dev_err(ap0202->dev, "sensor setting failed at index:%d\n",i);
						break;
				    }
				
			 }
			 else // 1 means this register is 8bit basis
			 {
				 ret = ap0202_write_reg8(ap0202,ap0202_1080p[i],(u8)ap0202_1080p[i+1]);
				 if(ret<0)
					 {
						 dev_err(ap0202->dev, "sensor setting failed at index:%d\n",i);
						 break;
				 }
			 }
		
			 if(ap0202_1080p[i]==0x0040)
			  	msleep(15);
		}

		return ret;
	
}

static int tc358746_reg_init(struct ap0202 *ap0202,enum ap0202_mode mode)
{
	int size, ret,i;

	size = sizeof(reg_parallel_in_mipi_out) / sizeof(struct tc358746_reg_struct);
	
	for(i = 0; i < size; i++) {		
		if(reg_parallel_in_mipi_out[i].size == 2)			
			ret = toshiba_bridge_write_reg(ap0202, reg_parallel_in_mipi_out[i].addr, (u16)reg_parallel_in_mipi_out[i].val);
		else
			ret = toshiba_bridge_write_reg32(ap0202, reg_parallel_in_mipi_out[i].addr, reg_parallel_in_mipi_out[i].val);
		if(ret<0)
			{
				dev_err(ap0202->dev, "bridge setting failed at index:%d\n",i);			
				break;
			}
	}

	return ret;
}

static int ap0202_set_aec_mode(struct ap0202 *ap0202, u32 mode)
{
	u8 val;
	int ret;

	ret = ap0202_read_reg(ap0202, AP0202_AEC_PK_MANUAL, &val);
	if (ret < 0)
		return ret;

	if (mode == V4L2_EXPOSURE_AUTO)
		val &= ~AP0202_AEC_MANUAL_ENABLE;
	else /* V4L2_EXPOSURE_MANUAL */
		val |= AP0202_AEC_MANUAL_ENABLE;

	return ap0202_write_reg(ap0202, AP0202_AEC_PK_MANUAL, val);
}

static int ap0202_set_agc_mode(struct ap0202 *ap0202, u32 enable)
{
	u8 val;
	int ret;

	ret = ap0202_read_reg(ap0202, AP0202_AEC_PK_MANUAL, &val);
	if (ret < 0)
		return ret;

	if (enable)
		val &= ~AP0202_AGC_MANUAL_ENABLE;
	else
		val |= AP0202_AGC_MANUAL_ENABLE;

	return ap0202_write_reg(ap0202, AP0202_AEC_PK_MANUAL, val);
}

static int ap0202_set_register_array(struct ap0202 *ap0202,
				     struct reg_value *settings,
				     u32 num_settings)
{
	u16 reg;
	u8 val;
	u32 i;
	int ret;

	for (i = 0; i < num_settings; ++i, ++settings) {
		reg = settings->reg;
		val = settings->val;

		ret = ap0202_write_reg(ap0202, reg, val);
		if (ret < 0)
			return ret;
	}

	return 0;
}



static int ap0202_change_mode(struct ap0202 *ap0202, enum ap0202_mode mode)
{
	int ret;
/*
	struct reg_value *settings;
	u32 num_settings;

	settings = ap0202_mode_info_data[mode].data;
	num_settings = ap0202_mode_info_data[mode].data_size;
*/

    //it may take the mode parameter in next update
    
	ret = ap0202_init(ap0202,mode);

	ret |= tc358746_reg_init(ap0202,mode);
	
	return ret;
}

static int ap0202_set_power_on(struct ap0202 *ap0202)
{
	int ret;

	clk_set_rate(ap0202->xclk, ap0202->xclk_freq);

	ret = clk_prepare_enable(ap0202->xclk);
	if (ret < 0) {
		dev_err(ap0202->dev, "clk prepare enable failed\n");
		return ret;
	}

	ret = ap0202_regulators_enable(ap0202);
	if (ret < 0) {
		clk_disable_unprepare(ap0202->xclk);
		return ret;
	}

	usleep_range(5000, 15000);
	gpiod_set_value_cansleep(ap0202->enable_gpio, 0);

	usleep_range(1000, 2000);
	gpiod_set_value_cansleep(ap0202->rst_gpio, 0);

	msleep(20);

	return ret;
}

static void ap0202_set_power_off(struct ap0202 *ap0202)
{
	gpiod_set_value_cansleep(ap0202->rst_gpio, 1);
	gpiod_set_value_cansleep(ap0202->enable_gpio, 1);
	ap0202_regulators_disable(ap0202);
	clk_disable_unprepare(ap0202->xclk);
}

static int ap0202_s_power(struct v4l2_subdev *sd, int on)
{
	struct ap0202 *ap0202 = to_ap0202(sd);
	int ret = 0;

	mutex_lock(&ap0202->power_lock);

	if (on) {
		ret = msm_cci_ctrl_init();
		if (ret < 0)
			goto exit;
	}

	if (ap0202->power == !on) {
		/* Power state changes. */
		if (on) {
			mutex_lock(&ap0202_lock);

			ret = ap0202_set_power_on(ap0202);
			if (ret < 0) {
				dev_err(ap0202->dev, "could not set power %s\n",
					on ? "on" : "off");
				goto exit;
			}

//don't change sensor i2c address for this time

//			ret = ap0202_write_reg_to(ap0202, 0x0109,
//					       ap0202->i2c_client->addr, 0xc0);


			if (ret < 0) {
				dev_err(ap0202->dev,
					"could not change i2c address\n");
				ap0202_set_power_off(ap0202);
				mutex_unlock(&ap0202_lock);
				goto exit;
			}

			mutex_unlock(&ap0202_lock);
/*
			ret = ap0202_init(ap0202);
			if (ret < 0) {
				dev_err(ap0202->dev,
					"could not set init registers\n");
				ap0202_set_power_off(ap0202);
				goto exit;
			}


			ret = ap0202_write_reg(ap0202, AP0202_SYSTEM_CTRL0,
					       AP0202_SYSTEM_CTRL0_STOP);
*/	

			if (ret < 0) {
				ap0202_set_power_off(ap0202);
				goto exit;
			}
		} else {
			ap0202_set_power_off(ap0202);
		}

		/* Update the power state. */
		ap0202->power = on ? true : false;
	}

exit:
	if (!on)
		msm_cci_ctrl_release();

	mutex_unlock(&ap0202->power_lock);

	return ret;
}


static int ap0202_set_saturation(struct ap0202 *ap0202, s32 value)
{
	u32 reg_value = (value * 0x10) + 0x40;
	int ret;

	ret = ap0202_write_reg(ap0202, AP0202_SDE_SAT_U, reg_value);
	if (ret < 0)
		return ret;

	ret = ap0202_write_reg(ap0202, AP0202_SDE_SAT_V, reg_value);

	return ret;
}

static int ap0202_set_hflip(struct ap0202 *ap0202, s32 value)
{
	u8 val;
	int ret;

	ret = ap0202_read_reg(ap0202, AP0202_TIMING_TC_REG21, &val);
	if (ret < 0)
		return ret;

	if (value == 0)
		val &= ~(AP0202_SENSOR_MIRROR);
	else
		val |= (AP0202_SENSOR_MIRROR);

	return ap0202_write_reg(ap0202, AP0202_TIMING_TC_REG21, val);
}

static int ap0202_set_vflip(struct ap0202 *ap0202, s32 value)
{
	u8 val;
	int ret;

	ret = ap0202_read_reg(ap0202, AP0202_TIMING_TC_REG20, &val);
	if (ret < 0)
		return ret;

	if (value == 0)
		val |= (AP0202_SENSOR_VFLIP | AP0202_ISP_VFLIP);
	else
		val &= ~(AP0202_SENSOR_VFLIP | AP0202_ISP_VFLIP);

	return ap0202_write_reg(ap0202, AP0202_TIMING_TC_REG20, val);
}

static int ap0202_set_test_pattern(struct ap0202 *ap0202, s32 value)
{
	u8 val;
	int ret;

	ret = ap0202_read_reg(ap0202, AP0202_PRE_ISP_TEST_SETTING_1, &val);
	if (ret < 0)
		return ret;

	if (value) {
		val &= ~AP0202_SET_TEST_PATTERN(AP0202_TEST_PATTERN_MASK);
		val |= AP0202_SET_TEST_PATTERN(value - 1);
		val |= AP0202_TEST_PATTERN_ENABLE;
	} else {
		val &= ~AP0202_TEST_PATTERN_ENABLE;
	}

	return ap0202_write_reg(ap0202, AP0202_PRE_ISP_TEST_SETTING_1, val);
}

static const char * const ap0202_test_pattern_menu[] = {
	"Disabled",
	"Vertical Color Bars",
	"Pseudo-Random Data",
	"Color Square",
	"Black Image",
};

static int ap0202_set_awb(struct ap0202 *ap0202, s32 enable_auto)
{
	u8 val;
	int ret;

	ret = ap0202_read_reg(ap0202, AP0202_AWB_MANUAL_CONTROL, &val);
	if (ret < 0)
		return ret;

	if (enable_auto)
		val &= ~AP0202_AWB_MANUAL_ENABLE;
	else
		val |= AP0202_AWB_MANUAL_ENABLE;

	return ap0202_write_reg(ap0202, AP0202_AWB_MANUAL_CONTROL, val);
}

static int ap0202_s_ctrl(struct v4l2_ctrl *ctrl)
{
	struct ap0202 *ap0202 = container_of(ctrl->handler,
					     struct ap0202, ctrls);

	int ret = -EINVAL;

	return 0;	
	mutex_lock(&ap0202->power_lock);
	if (ap0202->power == 0) {
		mutex_unlock(&ap0202->power_lock);
		return 0;
	}

	switch (ctrl->id) {
	case V4L2_CID_SATURATION:
		ret = ap0202_set_saturation(ap0202, ctrl->val);
		break;
	case V4L2_CID_AUTO_WHITE_BALANCE:
		ret = ap0202_set_awb(ap0202, ctrl->val);
		break;
	case V4L2_CID_AUTOGAIN:
		ret = ap0202_set_agc_mode(ap0202, ctrl->val);
		break;
	case V4L2_CID_EXPOSURE_AUTO:
		ret = ap0202_set_aec_mode(ap0202, ctrl->val);
		break;
	case V4L2_CID_TEST_PATTERN:
		ret = ap0202_set_test_pattern(ap0202, ctrl->val);
		break;
	case V4L2_CID_HFLIP:
		ret = ap0202_set_hflip(ap0202, ctrl->val);
		break;
	case V4L2_CID_VFLIP:
		ret = ap0202_set_vflip(ap0202, ctrl->val);
		break;
	}

	mutex_unlock(&ap0202->power_lock);

	return ret;
}

static struct v4l2_ctrl_ops ap0202_ctrl_ops = {
	.s_ctrl = ap0202_s_ctrl,
};

static int ap0202_entity_init_cfg(struct v4l2_subdev *subdev,
				  struct v4l2_subdev_pad_config *cfg)
{
	struct v4l2_subdev_format fmt = { 0 };
	struct ap0202 *ap0202 = to_ap0202(subdev);

	dev_err(ap0202->dev, "%s: Enter\n", __func__);


	fmt.which = cfg ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
	fmt.format.width = 1920;
	fmt.format.height = 1080;

	v4l2_subdev_call(subdev, pad, set_fmt, cfg, &fmt);

	return 0;
}

static int ap0202_enum_mbus_code(struct v4l2_subdev *sd,
				 struct v4l2_subdev_pad_config *cfg,
				 struct v4l2_subdev_mbus_code_enum *code)
{
	struct ap0202 *ap0202 = to_ap0202(sd);

	if (code->index > 0)
		return -EINVAL;

	code->code = ap0202->fmt.code;

	return 0;
}

static int ap0202_enum_frame_size(struct v4l2_subdev *subdev,
				  struct v4l2_subdev_pad_config *cfg,
				  struct v4l2_subdev_frame_size_enum *fse)
{
	if (fse->index > AP0202_MODE_MAX)
		return -EINVAL;

	fse->min_width = ap0202_mode_info_data[fse->index].width;
	fse->max_width = ap0202_mode_info_data[fse->index].width;
	fse->min_height = ap0202_mode_info_data[fse->index].height;
	fse->max_height = ap0202_mode_info_data[fse->index].height;

	return 0;
}

static struct v4l2_mbus_framefmt *
__ap0202_get_pad_format(struct ap0202 *ap0202,
			struct v4l2_subdev_pad_config *cfg,
			unsigned int pad,
			enum v4l2_subdev_format_whence which)
{
	switch (which) {
	case V4L2_SUBDEV_FORMAT_TRY:
		return v4l2_subdev_get_try_format(&ap0202->sd, cfg, pad);
	case V4L2_SUBDEV_FORMAT_ACTIVE:
		return &ap0202->fmt;
	default:
		return NULL;
	}
}

static int ap0202_get_format(struct v4l2_subdev *sd,
			     struct v4l2_subdev_pad_config *cfg,
			     struct v4l2_subdev_format *format)
{
	struct ap0202 *ap0202 = to_ap0202(sd);

	format->format = *__ap0202_get_pad_format(ap0202, cfg, format->pad,
						  format->which);
	return 0;
}

static struct v4l2_rect *
__ap0202_get_pad_crop(struct ap0202 *ap0202, struct v4l2_subdev_pad_config *cfg,
		      unsigned int pad, enum v4l2_subdev_format_whence which)
{
	switch (which) {
	case V4L2_SUBDEV_FORMAT_TRY:
		return v4l2_subdev_get_try_crop(&ap0202->sd, cfg, pad);
	case V4L2_SUBDEV_FORMAT_ACTIVE:
		return &ap0202->crop;
	default:
		return NULL;
	}
}

static enum ap0202_mode ap0202_find_nearest_mode(struct ap0202 *ap0202,
						 int width, int height)
{
	int i;

	for (i = AP0202_MODE_MAX; i >= 0; i--) {
		if (ap0202_mode_info_data[i].width <= width &&
		    ap0202_mode_info_data[i].height <= height)
			break;
	}

	if (i < 0)
		i = 0;

	return (enum ap0202_mode)i;
}

static int ap0202_set_format(struct v4l2_subdev *sd,
			     struct v4l2_subdev_pad_config *cfg,
			     struct v4l2_subdev_format *format)
{
	struct ap0202 *ap0202 = to_ap0202(sd);
	struct v4l2_mbus_framefmt *__format;
	struct v4l2_rect *__crop;
	enum ap0202_mode new_mode;

	__crop = __ap0202_get_pad_crop(ap0202, cfg, format->pad,
			format->which);

	new_mode = ap0202_find_nearest_mode(ap0202,
			format->format.width, format->format.height);
	
	printk("set format,new mode index:%d",new_mode);

	
	__crop->width = ap0202_mode_info_data[new_mode].width;
	__crop->height = ap0202_mode_info_data[new_mode].height;

	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)
		ap0202->current_mode = new_mode;

	__format = __ap0202_get_pad_format(ap0202, cfg, format->pad,
			format->which);
	__format->width = __crop->width;
	__format->height = __crop->height;
	__format->code = MEDIA_BUS_FMT_YUYV8_2X8;
	__format->field = V4L2_FIELD_NONE;
	__format->colorspace = V4L2_COLORSPACE_SRGB;

	format->format = *__format;

	return 0;
}

static int ap0202_get_selection(struct v4l2_subdev *sd,
			   struct v4l2_subdev_pad_config *cfg,
			   struct v4l2_subdev_selection *sel)
{
	struct ap0202 *ap0202 = to_ap0202(sd);

	if (sel->target != V4L2_SEL_TGT_CROP)
		return -EINVAL;

	sel->r = *__ap0202_get_pad_crop(ap0202, cfg, sel->pad,
					sel->which);
	return 0;
}

static int ap0202_s_stream(struct v4l2_subdev *subdev, int enable)
{
	struct ap0202 *ap0202 = to_ap0202(subdev);
	int ret;

	if (enable) {
		ret = ap0202_change_mode(ap0202, ap0202->current_mode);//Do the non-match test
		if (ret < 0) {
			dev_err(ap0202->dev, "could not set mode %d\n",
				ap0202->current_mode);
			return ret;
		}else
			{
			printk("new mode index:%d",ap0202->current_mode);
		}

/*		
		ret = v4l2_ctrl_handler_setup(&ap0202->ctrls);
		if (ret < 0) {
			dev_err(ap0202->dev, "could not sync v4l2 controls\n");
			return ret;
		}
//		ret = ap0202_write_reg(ap0202, AP0202_SYSTEM_CTRL0,
//				       AP0202_SYSTEM_CTRL0_START);
		if (ret < 0)
		return ret;

*/
	} else {
		//Check register to disable streaming,sensor or bridge
		ret = ap0202_write_reg(ap0202, AP0202_SYSTEM_CTRL0,
				       AP0202_SYSTEM_CTRL0_STOP);
		if (ret < 0)
			return ret;
	}

	return 0;
}

static struct v4l2_subdev_core_ops ap0202_core_ops = {
	.s_power = ap0202_s_power,
};

static struct v4l2_subdev_video_ops ap0202_video_ops = {
	.s_stream = ap0202_s_stream,
};

static struct v4l2_subdev_pad_ops ap0202_subdev_pad_ops = {
	.enum_mbus_code = ap0202_enum_mbus_code,
	.enum_frame_size = ap0202_enum_frame_size,
	.get_fmt = ap0202_get_format,
	.set_fmt = ap0202_set_format,
	.get_selection = ap0202_get_selection,
};

static struct v4l2_subdev_ops ap0202_subdev_ops = {
	.core = &ap0202_core_ops,
	.video = &ap0202_video_ops,
	.pad = &ap0202_subdev_pad_ops,
};

static const struct v4l2_subdev_internal_ops ap0202_subdev_internal_ops = {
};

static int ap0202_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	struct device *dev = &client->dev;
	struct device_node *endpoint;
	struct ap0202 *ap0202;
	u16 chip_id,bridge_id;
	u16 alpha = 0;
	u16 beta = 0;
	
	int ret;

	client->addr = 0x90;

	dev_dbg(dev, "%s: Enter, i2c addr = 0x%x\n", __func__, client->addr);
	
	ap0202 = devm_kzalloc(dev, sizeof(struct ap0202), GFP_KERNEL);
	if (!ap0202)
		return -ENOMEM;

	ap0202->i2c_client = client;
	ap0202->dev = dev;

	endpoint = of_graph_get_next_endpoint(dev->of_node, NULL);
	if (!endpoint) {
		dev_err(dev, "endpoint node not found\n");
		return -EINVAL;
	}

	ret = v4l2_of_parse_endpoint(endpoint, &ap0202->ep);
	if (ret < 0) {
		dev_err(dev, "parsing endpoint node failed\n");
		return ret;
	}
	if (ap0202->ep.bus_type != V4L2_MBUS_CSI2) {
		dev_err(dev, "invalid bus type, must be CSI2\n");
		of_node_put(endpoint);
		return -EINVAL;
	}
	of_node_put(endpoint);

	/* get system clock (xclk) */
	ap0202->xclk = devm_clk_get(dev, "xclk");
	if (IS_ERR(ap0202->xclk)) {
		dev_err(dev, "could not get xclk");
		return PTR_ERR(ap0202->xclk);
	}

	ret = of_property_read_u32(dev->of_node, "clock-frequency",
				    &ap0202->xclk_freq);
	if (ret) {
		dev_err(dev, "could not get xclk frequency\n");
		return ret;
	}

	ap0202->io_regulator = devm_regulator_get(dev, "vdddo");
	if (IS_ERR(ap0202->io_regulator)) {
		dev_err(dev, "cannot get io regulator\n");
		return PTR_ERR(ap0202->io_regulator);
	}

	ret = regulator_set_voltage(ap0202->io_regulator,
				    AP0202_VOLTAGE_DIGITAL_IO,
				    AP0202_VOLTAGE_DIGITAL_IO);
	if (ret < 0) {
		dev_err(dev, "cannot set io voltage\n");
		return ret;
	}

	ap0202->core_regulator = devm_regulator_get(dev, "vddd");
	if (IS_ERR(ap0202->core_regulator)) {
		dev_err(dev, "cannot get core regulator\n");
		return PTR_ERR(ap0202->core_regulator);
	}

	ret = regulator_set_voltage(ap0202->core_regulator,
				    AP0202_VOLTAGE_DIGITAL_CORE,
				    AP0202_VOLTAGE_DIGITAL_CORE);
	if (ret < 0) {
		dev_err(dev, "cannot set core voltage\n");
		return ret;
	}

	ap0202->analog_regulator = devm_regulator_get(dev, "vdda");
	if (IS_ERR(ap0202->analog_regulator)) {
		dev_err(dev, "cannot get analog regulator\n");
		return PTR_ERR(ap0202->analog_regulator);
	}

	ret = regulator_set_voltage(ap0202->analog_regulator,
				    AP0202_VOLTAGE_ANALOG,
				    AP0202_VOLTAGE_ANALOG);
	if (ret < 0) {
		dev_err(dev, "cannot set analog voltage\n");
		return ret;
	}

	ap0202->enable_gpio = devm_gpiod_get(dev, "enable", GPIOD_OUT_HIGH);
	if (IS_ERR(ap0202->enable_gpio)) {
		dev_err(dev, "cannot get enable gpio\n");
		return PTR_ERR(ap0202->enable_gpio);
	}

	ap0202->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
	if (IS_ERR(ap0202->rst_gpio)) {
		dev_err(dev, "cannot get reset gpio\n");
		return PTR_ERR(ap0202->rst_gpio);
	}

	mutex_init(&ap0202->power_lock);

	v4l2_ctrl_handler_init(&ap0202->ctrls, 7);
	ap0202->saturation = v4l2_ctrl_new_std(&ap0202->ctrls, &ap0202_ctrl_ops,
				V4L2_CID_SATURATION, -4, 4, 1, 0);
	ap0202->hflip = v4l2_ctrl_new_std(&ap0202->ctrls, &ap0202_ctrl_ops,
				V4L2_CID_HFLIP, 0, 1, 1, 0);
	ap0202->vflip = v4l2_ctrl_new_std(&ap0202->ctrls, &ap0202_ctrl_ops,
				V4L2_CID_VFLIP, 0, 1, 1, 0);
	ap0202->autogain = v4l2_ctrl_new_std(&ap0202->ctrls, &ap0202_ctrl_ops,
				V4L2_CID_AUTOGAIN, 0, 1, 1, 1);
	ap0202->autoexposure = v4l2_ctrl_new_std_menu(&ap0202->ctrls,
				&ap0202_ctrl_ops, V4L2_CID_EXPOSURE_AUTO,
				V4L2_EXPOSURE_MANUAL, 0, V4L2_EXPOSURE_AUTO);
	ap0202->awb = v4l2_ctrl_new_std(&ap0202->ctrls, &ap0202_ctrl_ops,
				V4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);
	ap0202->pattern = v4l2_ctrl_new_std_menu_items(&ap0202->ctrls,
				&ap0202_ctrl_ops, V4L2_CID_TEST_PATTERN,
				ARRAY_SIZE(ap0202_test_pattern_menu) - 1, 0, 0,
				ap0202_test_pattern_menu);

	ap0202->sd.ctrl_handler = &ap0202->ctrls;

	if (ap0202->ctrls.error) {
		dev_err(dev, "%s: control initialization error %d\n",
		       __func__, ap0202->ctrls.error);
		ret = ap0202->ctrls.error;
		goto free_ctrl;
	}

	v4l2_i2c_subdev_init(&ap0202->sd, client, &ap0202_subdev_ops);
	ap0202->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
	ap0202->pad.flags = MEDIA_PAD_FL_SOURCE;
	ap0202->sd.internal_ops = &ap0202_subdev_internal_ops;

	ret = media_entity_init(&ap0202->sd.entity, 1, &ap0202->pad, 0);
	if (ret < 0) {
		dev_err(dev, "could not register media entity\n");
		goto free_ctrl;
	}

	ap0202->sd.dev = &client->dev;
	ret = v4l2_async_register_subdev(&ap0202->sd);
	if (ret < 0) {
		dev_err(dev, "could not register v4l2 device\n");
		goto free_entity;
	}

	ret = ap0202_s_power(&ap0202->sd, true);
	if (ret < 0) {
		dev_err(dev, "could not power up AP0202\n");
		goto unregister_subdev;
	}

	ret = ap0202_read_reg(ap0202, AP0202_CHIP_ID, &chip_id);
	if (ret < 0 || chip_id != AP0202_CHIP_ID_WORD) {
		dev_err(dev, "could not read sensor ID ,%x\n",chip_id);
		ret = -ENODEV;
		goto power_down;
	}

	dev_info(dev, "AP0202 detected at address 0x%x,ID:0x%x\n", client->addr,chip_id);

	ret = toshiba_bridge_read_reg(ap0202, TOSHIBA_BRG_ID, &bridge_id);

	if (ret< 0 || bridge_id != TOSHIBA_BRG_ID_WORD) {
		dev_err(dev, "could not read bridge ID,%x\n",bridge_id);
		ret = -ENODEV;
		goto power_down;
	}
	dev_info(dev, "TOSHIBA MIPI bridge detected at address 0x%x,ID:0x%x\n", client->addr,bridge_id);


/*
	ap0202_write_reg(ap0202, 0x04, 0x0280);

	toshiba_bridge_write_reg(ap0202, 0x0016, 0x504D);

	toshiba_bridge_read_reg(ap0202, 0x0016, &alpha);
	
	dev_info(dev, "Toshiba bridge reg alpha:0x%x\n", alpha);

	toshiba_bridge_write_reg32(ap0202, 0x0500, 0xA30080A3);


	ap0202_read_reg(ap0202, 0x04, &beta);
	dev_info(dev, "AP0202 reg beta:0x%x\n", beta);

	*/
		
	ap0202_s_power(&ap0202->sd, false);

	ap0202_entity_init_cfg(&ap0202->sd, NULL);

	return 0;

power_down:
	ap0202_s_power(&ap0202->sd, false);
unregister_subdev:
	v4l2_async_unregister_subdev(&ap0202->sd);
free_entity:
	media_entity_cleanup(&ap0202->sd.entity);
free_ctrl:
	v4l2_ctrl_handler_free(&ap0202->ctrls);
	mutex_destroy(&ap0202->power_lock);

	return ret;
}


static int ap0202_remove(struct i2c_client *client)
{
	struct v4l2_subdev *sd = i2c_get_clientdata(client);
	struct ap0202 *ap0202 = to_ap0202(sd);

	v4l2_async_unregister_subdev(&ap0202->sd);
	media_entity_cleanup(&ap0202->sd.entity);
	v4l2_ctrl_handler_free(&ap0202->ctrls);
	mutex_destroy(&ap0202->power_lock);

	return 0;
}


static const struct i2c_device_id ap0202_id[] = {
	{ "ap0202", 0 },
	{}
};
MODULE_DEVICE_TABLE(i2c, ap0202_id);

static const struct of_device_id ap0202_of_match[] = {
	{ .compatible = "onsemi,ap0202" },
	{ /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, ap0202_of_match);

static struct i2c_driver ap0202_i2c_driver = {
	.driver = {
		.of_match_table = of_match_ptr(ap0202_of_match),
		.name  = "ap0202",
	},
	.probe  = ap0202_probe,
	.remove = ap0202_remove,
	.id_table = ap0202_id,
};

module_i2c_driver(ap0202_i2c_driver);

MODULE_DESCRIPTION("Onsemi AP0202 Camera Driver");
MODULE_AUTHOR("Kevin Wun <kevin.w@aistarvision.com>");
MODULE_LICENSE("GPL v2");
